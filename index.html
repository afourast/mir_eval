
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>mir_eval Documentation &#8212; mir_eval 0.5 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Changes" href="changes.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="changes.html" title="Changes"
             accesskey="N">next</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">mir_eval 0.5 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="mir-eval-documentation">
<h1><code class="docutils literal"><span class="pre">mir_eval</span></code> Documentation<a class="headerlink" href="#mir-eval-documentation" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal"><span class="pre">mir_eval</span></code> is a Python library which provides a transparent, standaridized, and straightforward way to evaluate Music Information Retrieval systems.</p>
<p>If you use <code class="docutils literal"><span class="pre">mir_eval</span></code> in a research project, please cite the following paper:</p>
<ol class="upperalpha simple" start="3">
<li>Raffel, B. McFee, E. J. Humphrey, J. Salamon, O. Nieto, D. Liang, and D. P. W. Ellis, <a class="reference external" href="http://colinraffel.com/publications/ismir2014mir_eval.pdf">“mir_eval: A Transparent Implementation of Common MIR Metrics”</a>, Proceedings of the 15th International Conference on Music Information Retrieval, 2014.</li>
</ol>
<div class="section" id="installing-mir-eval">
<span id="installation"></span><h2>Installing <code class="docutils literal"><span class="pre">mir_eval</span></code><a class="headerlink" href="#installing-mir-eval" title="Permalink to this headline">¶</a></h2>
<p>The simplest way to install <code class="docutils literal"><span class="pre">mir_eval</span></code> is by using <code class="docutils literal"><span class="pre">pip</span></code>, which will also install the required dependencies if needed.
To install <code class="docutils literal"><span class="pre">mir_eval</span></code> using <code class="docutils literal"><span class="pre">pip</span></code>, simply run</p>
<p><code class="docutils literal"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">mir_eval</span></code></p>
<p>Alternatively, you can install <code class="docutils literal"><span class="pre">mir_eval</span></code> from source by first installing the dependencies and then running</p>
<p><code class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code></p>
<p>from the source directory.</p>
<p>If you don’t use Python and want to get started as quickly as possible, you might consider using <a class="reference external" href="https://store.continuum.io/cshop/anaconda/">Anaconda</a> which makes it easy to install a Python environment which can run <code class="docutils literal"><span class="pre">mir_eval</span></code>.</p>
</div>
<div class="section" id="using-mir-eval">
<h2>Using <code class="docutils literal"><span class="pre">mir_eval</span></code><a class="headerlink" href="#using-mir-eval" title="Permalink to this headline">¶</a></h2>
<p>Once you’ve installed <code class="docutils literal"><span class="pre">mir_eval</span></code> (see <a class="reference internal" href="#installation"><span class="std std-ref">Installing mir_eval</span></a>), you can import it in your Python code as follows:</p>
<p><code class="docutils literal"><span class="pre">import</span> <span class="pre">mir_eval</span></code></p>
<p>From here, you will typically either load in data and call the <code class="docutils literal"><span class="pre">evaluate()</span></code> function from the appropriate submodule like so:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference_beats.txt&#39;</span><span class="p">)</span>
<span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated_beats.txt&#39;</span><span class="p">)</span>
<span class="c1"># Scores will be a dict containing scores for all of the metrics</span>
<span class="c1"># implemented in mir_eval.beat.  The keys are metric names</span>
<span class="c1"># and values are the scores achieved</span>
<span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
<p>or you’ll load in the data, do some preprocessing, and call specific metric functions from the appropriate submodule like so:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference_beats.txt&#39;</span><span class="p">)</span>
<span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated_beats.txt&#39;</span><span class="p">)</span>
<span class="c1"># Crop out beats before 5s, a common preprocessing step</span>
<span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="c1"># Compute the F-measure metric and store it in f_measure</span>
<span class="n">f_measure</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">f_measure</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
<p>The documentation for each metric function, found in the <a class="reference internal" href="#mir-eval"><span class="std std-ref">mir_eval</span></a> section below, contains further usage information.</p>
<p>Alternatively, you can use the evaluator scripts which allow you to run evaluation from the command line, without writing any code.
These scripts are are available here:</p>
<p><a class="reference external" href="https://github.com/craffel/mir_evaluators">https://github.com/craffel/mir_evaluators</a></p>
</div>
<div class="section" id="mir-eval">
<span id="id1"></span><h2><code class="docutils literal"><span class="pre">mir_eval</span></code><a class="headerlink" href="#mir-eval" title="Permalink to this headline">¶</a></h2>
<p>The structure of the <code class="docutils literal"><span class="pre">mir_eval</span></code> Python module is as follows:
Each MIR task for which evaluation metrics are included in <code class="docutils literal"><span class="pre">mir_eval</span></code> is given its own submodule, and each metric is defined as a separate function in each submodule.
Every metric function includes detailed documentation, example usage, input validation, and references to the original paper which defined the metric (see the subsections below).
The task submodules also all contain a function <code class="docutils literal"><span class="pre">evaluate()</span></code>, which takes as input reference and estimated annotations and returns a dictionary of scores for all of the metrics implemented (for casual users, this is the place to start).
Finally, each task submodule also includes functions for common data pre-processing steps.</p>
<p><code class="docutils literal"><span class="pre">mir_eval</span></code> also includes the following additional submodules:</p>
<ul class="simple">
<li><a class="reference internal" href="#module-mir_eval.io" title="mir_eval.io"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.io</span></code></a> which contains convenience functions for loading in task-specific data from common file formats</li>
<li><a class="reference internal" href="#module-mir_eval.util" title="mir_eval.util"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.util</span></code></a> which includes miscellaneous functionality shared across the submodules</li>
<li><a class="reference internal" href="#module-mir_eval.sonify" title="mir_eval.sonify"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.sonify</span></code></a> which implements some simple methods for synthesizing annotations of various formats for “evaluation by ear”.</li>
<li><a class="reference internal" href="#module-mir_eval.display" title="mir_eval.display"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.display</span></code></a> which provides functions for plotting annotations for various tasks.</li>
</ul>
<p>The following subsections document each submodule.</p>
<div class="section" id="module-mir_eval.beat">
<span id="mir-eval-beat"></span><h3><a class="reference internal" href="#module-mir_eval.beat" title="mir_eval.beat"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.beat</span></code></a><a class="headerlink" href="#module-mir_eval.beat" title="Permalink to this headline">¶</a></h3>
<p>The aim of a beat detection algorithm is to report the times at which a typical
human listener might tap their foot to a piece of music. As a result, most
metrics for evaluating the performance of beat tracking systems involve
computing the error between the estimated beat times and some reference list of
beat locations. Many metrics additionally compare the beat sequences at
different metric levels in order to deal with the ambiguity of tempo.</p>
<dl class="docutils">
<dt>Based on the methods described in:</dt>
<dd>Matthew E. P. Davies,  Norberto Degara, and Mark D. Plumbley.
“Evaluation Methods for Musical Audio Beat Tracking Algorithms”,
Queen Mary University of London Technical Report C4DM-TR-09-06
London, United Kingdom, 8 October 2009.</dd>
<dt>See also the Beat Evaluation Toolbox:</dt>
<dd><a class="reference external" href="https://code.soundsoftware.ac.uk/projects/beat-evaluation/">https://code.soundsoftware.ac.uk/projects/beat-evaluation/</a></dd>
</dl>
<div class="section" id="conventions">
<h4>Conventions<a class="headerlink" href="#conventions" title="Permalink to this headline">¶</a></h4>
<p>Beat times should be provided in the form of a 1-dimensional array of beat
times in seconds in increasing order.  Typically, any beats which occur before
5s are ignored; this can be accomplished using
<a class="reference internal" href="#mir_eval.beat.trim_beats" title="mir_eval.beat.trim_beats"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.trim_beats()</span></code></a>.</p>
</div>
<div class="section" id="metrics">
<h4>Metrics<a class="headerlink" href="#metrics" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.beat.f_measure" title="mir_eval.beat.f_measure"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.f_measure()</span></code></a>: The F-measure of the beat sequence, where an
estimated beat is considered correct if it is sufficiently close to a
reference beat</li>
<li><a class="reference internal" href="#mir_eval.beat.cemgil" title="mir_eval.beat.cemgil"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.cemgil()</span></code></a>: Cemgil’s score, which computes the sum of
Gaussian errors for each beat</li>
<li><a class="reference internal" href="#mir_eval.beat.goto" title="mir_eval.beat.goto"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.goto()</span></code></a>: Goto’s score, a binary score which is 1 when at
least 25% of the estimated beat sequence closely matches the reference beat
sequence</li>
<li><a class="reference internal" href="#mir_eval.beat.p_score" title="mir_eval.beat.p_score"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.p_score()</span></code></a>: McKinney’s P-score, which computes the
cross-correlation of the estimated and reference beat sequences represented
as impulse trains</li>
<li><a class="reference internal" href="#mir_eval.beat.continuity" title="mir_eval.beat.continuity"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.continuity()</span></code></a>: Continuity-based scores which compute the
proportion of the beat sequence which is continuously correct</li>
<li><a class="reference internal" href="#mir_eval.beat.information_gain" title="mir_eval.beat.information_gain"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.information_gain()</span></code></a>: The Information Gain of a normalized
beat error histogram over a uniform distribution</li>
</ul>
<dl class="function">
<dt id="mir_eval.beat.trim_beats">
<code class="descclassname">mir_eval.beat.</code><code class="descname">trim_beats</code><span class="sig-paren">(</span><em>beats</em>, <em>min_beat_time=5.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.trim_beats" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes beats before min_beat_time.  A common preprocessing step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>beats</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of beat times in seconds.</p>
</div></blockquote>
<p><strong>min_beat_time</strong> : float</p>
<blockquote>
<div><p>Minimum beat time to allow
(Default value = 5.)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>beats_trimmed</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Trimmed beat array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.validate">
<code class="descclassname">mir_eval.beat.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid beat time
arrays, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>estimated beat times, in seconds</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.f_measure">
<code class="descclassname">mir_eval.beat.</code><code class="descname">f_measure</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em>, <em>f_measure_threshold=0.07</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the F-measure of correct vs incorrectly predicted beats.
“Correctness” is determined over a small window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>estimated beat times, in seconds</p>
</div></blockquote>
<p><strong>f_measure_threshold</strong> : float</p>
<blockquote>
<div><p>Window size, in seconds
(Default value = 0.07)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_score</strong> : float</p>
<blockquote class="last">
<div><p>The computed F-measure score</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_measure</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">f_measure</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                        estimated_beats)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.cemgil">
<code class="descclassname">mir_eval.beat.</code><code class="descname">cemgil</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em>, <em>cemgil_sigma=0.04</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.cemgil" title="Permalink to this definition">¶</a></dt>
<dd><p>Cemgil’s score, computes a gaussian error of each estimated beat.
Compares against the original beat times and all metrical variations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>query beat times, in seconds</p>
</div></blockquote>
<p><strong>cemgil_sigma</strong> : float</p>
<blockquote>
<div><p>Sigma parameter of gaussian error windows
(Default value = 0.04)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cemgil_score</strong> : float</p>
<blockquote>
<div><p>Cemgil’s score for the original reference beats</p>
</div></blockquote>
<p><strong>cemgil_max</strong> : float</p>
<blockquote class="last">
<div><p>The best Cemgil score for all metrical variations</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cemgil_score</span><span class="p">,</span> <span class="n">cemgil_max</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">cemgil</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                                    estimated_beats)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.goto">
<code class="descclassname">mir_eval.beat.</code><code class="descname">goto</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em>, <em>goto_threshold=0.35</em>, <em>goto_mu=0.2</em>, <em>goto_sigma=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.goto" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Goto’s score, a binary 1 or 0 depending on some specific
heuristic criteria</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>query beat times, in seconds</p>
</div></blockquote>
<p><strong>goto_threshold</strong> : float</p>
<blockquote>
<div><p>Threshold of beat error for a beat to be “correct”
(Default value = 0.35)</p>
</div></blockquote>
<p><strong>goto_mu</strong> : float</p>
<blockquote>
<div><p>The mean of the beat errors in the continuously correct
track must be less than this
(Default value = 0.2)</p>
</div></blockquote>
<p><strong>goto_sigma</strong> : float</p>
<blockquote>
<div><p>The std of the beat errors in the continuously correct track must
be less than this
(Default value = 0.2)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>goto_score</strong> : float</p>
<blockquote class="last">
<div><p>Either 1.0 or 0.0 if some specific criteria are met</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">goto_score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">goto</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.p_score">
<code class="descclassname">mir_eval.beat.</code><code class="descname">p_score</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em>, <em>p_score_threshold=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.p_score" title="Permalink to this definition">¶</a></dt>
<dd><p>Get McKinney’s P-score.
Based on the autocorrelation of the reference and estimated beats</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>query beat times, in seconds</p>
</div></blockquote>
<p><strong>p_score_threshold</strong> : float</p>
<blockquote>
<div><p>Window size will be
<code class="docutils literal"><span class="pre">p_score_threshold*np.median(inter_annotation_intervals)</span></code>,
(Default value = 0.2)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>correlation</strong> : float</p>
<blockquote class="last">
<div><p>McKinney’s P-score</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">p_score</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.continuity">
<code class="descclassname">mir_eval.beat.</code><code class="descname">continuity</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em>, <em>continuity_phase_threshold=0.175</em>, <em>continuity_period_threshold=0.175</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.continuity" title="Permalink to this definition">¶</a></dt>
<dd><p>Get metrics based on how much of the estimated beat sequence is
continually correct.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>query beat times, in seconds</p>
</div></blockquote>
<p><strong>continuity_phase_threshold</strong> : float</p>
<blockquote>
<div><p>Allowable ratio of how far is the estimated beat
can be from the reference beat
(Default value = 0.175)</p>
</div></blockquote>
<p><strong>continuity_period_threshold</strong> : float</p>
<blockquote>
<div><p>Allowable distance between the inter-beat-interval
and the inter-annotation-interval
(Default value = 0.175)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>CMLc</strong> : float</p>
<blockquote>
<div><p>Correct metric level, continuous accuracy</p>
</div></blockquote>
<p><strong>CMLt</strong> : float</p>
<blockquote>
<div><p>Correct metric level, total accuracy (continuity not required)</p>
</div></blockquote>
<p><strong>AMLc</strong> : float</p>
<blockquote>
<div><p>Any metric level, continuous accuracy</p>
</div></blockquote>
<p><strong>AMLt</strong> : float</p>
<blockquote class="last">
<div><p>Any metric level, total accuracy (continuity not required)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CMLc</span><span class="p">,</span> <span class="n">CMLt</span><span class="p">,</span> <span class="n">AMLc</span><span class="p">,</span> <span class="n">AMLt</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">continuity</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                                      estimated_beats)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.information_gain">
<code class="descclassname">mir_eval.beat.</code><code class="descname">information_gain</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em>, <em>bins=41</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.information_gain" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the information gain - K-L divergence of the beat error histogram
to a uniform histogram</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>query beat times, in seconds</p>
</div></blockquote>
<p><strong>bins</strong> : int</p>
<blockquote>
<div><p>Number of bins in the beat error histogram
(Default value = 41)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>information_gain_score</strong> : float</p>
<blockquote class="last">
<div><p>Entropy of beat error histogram</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">information_gain</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">information_gain</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                                      estimated_beats)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.evaluate">
<code class="descclassname">mir_eval.beat.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>Query beat times, in seconds</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.chord">
<span id="mir-eval-chord"></span><h3><a class="reference internal" href="#module-mir_eval.chord" title="mir_eval.chord"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.chord</span></code></a><a class="headerlink" href="#module-mir_eval.chord" title="Permalink to this headline">¶</a></h3>
<p>Chord estimation algorithms produce a list of intervals and labels which denote
the chord being played over each timespan.  They are evaluated by comparing the
estimated chord labels to some reference, usually using a mapping to a chord
subalphabet (e.g. minor and major chords only, all triads, etc.).  There is no
single ‘right’ way to compare two sequences of chord labels.  Embracing this
reality, every conventional comparison rule is provided.  Comparisons are made
over the different components of each chord (e.g. G:maj(6)/5): the root (G),
the root-invariant active semitones as determined by the quality
shorthand (maj) and scale degrees (6), and the bass interval (5).
This submodule provides functions both for comparing a sequences of chord
labels according to some chord subalphabet mapping and for using these
comparisons to score a sequence of estimated chords against a reference.</p>
<div class="section" id="id2">
<h4>Conventions<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>A sequence of chord labels is represented as a list of strings, where each
label is the chord name based on the syntax of <a class="footnote-reference" href="#harte2010towards" id="id3">[1]</a>.  Reference
and estimated chord label sequences should be of the same length for comparison
functions.  When converting the chord string into its constituent parts,</p>
<ul class="simple">
<li>Pitch class counting starts at C, e.g. C:0, D:2, E:4, F:5, etc.</li>
<li>Scale degree is represented as a string of the diatonic interval, relative to
the root note, e.g. ‘b6’, ‘#5’, or ‘7’</li>
<li>Bass intervals are represented as strings</li>
<li>Chord bitmaps are positional binary vectors indicating active pitch classes
and may be absolute or relative depending on context in the code.</li>
</ul>
<p>If no chord is present at a given point in time, it should have the label ‘N’,
which is defined in the variable <code class="docutils literal"><span class="pre">mir_eval.chord.NO_CHORD</span></code>.</p>
</div>
<div class="section" id="id4">
<h4>Metrics<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.chord.root" title="mir_eval.chord.root"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.root()</span></code></a>: Only compares the root of the chords.</li>
<li><a class="reference internal" href="#mir_eval.chord.majmin" title="mir_eval.chord.majmin"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.majmin()</span></code></a>: Only compares major, minor, and “no chord”
labels.</li>
<li><a class="reference internal" href="#mir_eval.chord.majmin_inv" title="mir_eval.chord.majmin_inv"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.majmin_inv()</span></code></a>: Compares major/minor chords, with
inversions.  The bass note must exist in the triad.</li>
<li><a class="reference internal" href="#mir_eval.chord.mirex" title="mir_eval.chord.mirex"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.mirex()</span></code></a>: A estimated chord is considered correct if it
shares <em>at least</em> three pitch classes in common.</li>
<li><a class="reference internal" href="#mir_eval.chord.thirds" title="mir_eval.chord.thirds"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.thirds()</span></code></a>: Chords are compared at the level of major or
minor thirds (root and third), For example, both (‘A:7’, ‘A:maj’) and
(‘A:min’, ‘A:dim’) are equivalent, as the third is major and minor in
quality, respectively.</li>
<li><a class="reference internal" href="#mir_eval.chord.thirds_inv" title="mir_eval.chord.thirds_inv"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.thirds_inv()</span></code></a>: Same as above, with inversions (bass
relationships).</li>
<li><a class="reference internal" href="#mir_eval.chord.triads" title="mir_eval.chord.triads"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.triads()</span></code></a>: Chords are considered at the level of triads
(major, minor, augmented, diminished, suspended), meaning that, in addition
to the root, the quality is only considered through #5th scale degree (for
augmented chords). For example, (‘A:7’, ‘A:maj’) are equivalent, while
(‘A:min’, ‘A:dim’) and (‘A:aug’, ‘A:maj’) are not.</li>
<li><a class="reference internal" href="#mir_eval.chord.triads_inv" title="mir_eval.chord.triads_inv"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.triads_inv()</span></code></a>: Same as above, with inversions (bass
relationships).</li>
<li><a class="reference internal" href="#mir_eval.chord.tetrads" title="mir_eval.chord.tetrads"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.tetrads()</span></code></a>: Chords are considered at the level of the
entire quality in closed voicing, i.e. spanning only a single octave;
extended chords (9’s, 11’s and 13’s) are rolled into a single octave with any
upper voices included as extensions. For example, (‘A:7’, ‘A:9’) are
equivlent but (‘A:7’, ‘A:maj7’) are not.</li>
<li><a class="reference internal" href="#mir_eval.chord.tetrads_inv" title="mir_eval.chord.tetrads_inv"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.tetrads_inv()</span></code></a>: Same as above, with inversions (bass
relationships).</li>
<li><a class="reference internal" href="#mir_eval.chord.sevenths" title="mir_eval.chord.sevenths"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.sevenths()</span></code></a>: Compares according to MIREX “sevenths”
rules; that is, only major, major seventh, seventh, minor, minor seventh and
no chord labels are compared.</li>
<li><a class="reference internal" href="#mir_eval.chord.sevenths_inv" title="mir_eval.chord.sevenths_inv"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.sevenths_inv()</span></code></a>: Same as above, with inversions (bass
relationships).</li>
<li><a class="reference internal" href="#mir_eval.chord.overseg" title="mir_eval.chord.overseg"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.overseg()</span></code></a>: Computes the level of over-segmentation
between estimated and reference intervals.</li>
<li><a class="reference internal" href="#mir_eval.chord.underseg" title="mir_eval.chord.underseg"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.underseg()</span></code></a>: Computes the level of under-segmentation
between estimated and reference intervals.</li>
<li><a class="reference internal" href="#mir_eval.chord.seg" title="mir_eval.chord.seg"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.seg()</span></code></a>: Computes the minimum of over- and
under-segmentation between estimated and reference intervals.</li>
</ul>
</div>
<div class="section" id="references">
<h4>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><table class="docutils footnote" frame="void" id="harte2010towards" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> C. Harte. Towards Automatic Extraction of Harmony
Information from Music Signals. PhD thesis, Queen Mary University of
London, August 2010.</td></tr>
</tbody>
</table>
</div></blockquote>
<dl class="exception">
<dt id="mir_eval.chord.InvalidChordException">
<em class="property">exception </em><code class="descclassname">mir_eval.chord.</code><code class="descname">InvalidChordException</code><span class="sig-paren">(</span><em>message=''</em>, <em>chord_label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.InvalidChordException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Exception class for suspect / invalid chord labels</p>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.pitch_class_to_semitone">
<code class="descclassname">mir_eval.chord.</code><code class="descname">pitch_class_to_semitone</code><span class="sig-paren">(</span><em>pitch_class</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.pitch_class_to_semitone" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a pitch class to semitone.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>pitch_class</strong> : str</p>
<blockquote>
<div><p>Spelling of a given pitch class, e.g. ‘C#’, ‘Gbb’</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>semitone</strong> : int</p>
<blockquote class="last">
<div><p>Semitone value of the pitch class.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.scale_degree_to_semitone">
<code class="descclassname">mir_eval.chord.</code><code class="descname">scale_degree_to_semitone</code><span class="sig-paren">(</span><em>scale_degree</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.scale_degree_to_semitone" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a scale degree to semitone.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>scale degree</strong> : str</p>
<blockquote>
<div><p>Spelling of a relative scale degree, e.g. ‘b3’, ‘7’, ‘#5’</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>semitone</strong> : int</p>
<blockquote>
<div><p>Relative semitone of the scale degree, wrapped to a single octave</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>InvalidChordException if `scale_degree` is invalid.</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.scale_degree_to_bitmap">
<code class="descclassname">mir_eval.chord.</code><code class="descname">scale_degree_to_bitmap</code><span class="sig-paren">(</span><em>scale_degree</em>, <em>modulo=False</em>, <em>length=12</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.scale_degree_to_bitmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bitmap representation of a scale degree.</p>
<p>Note that values in the bitmap may be negative, indicating that the
semitone is to be removed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>scale_degree</strong> : str</p>
<blockquote>
<div><p>Spelling of a relative scale degree, e.g. ‘b3’, ‘7’, ‘#5’</p>
</div></blockquote>
<p><strong>modulo</strong> : bool, default=True</p>
<blockquote>
<div><p>If a scale degree exceeds the length of the bit-vector, modulo the
scale degree back into the bit-vector; otherwise it is discarded.</p>
</div></blockquote>
<p><strong>length</strong> : int, default=12</p>
<blockquote>
<div><p>Length of the bit-vector to produce</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bitmap</strong> : np.ndarray, in [-1, 0, 1], len=`length`</p>
<blockquote class="last">
<div><p>Bitmap representation of this scale degree.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.quality_to_bitmap">
<code class="descclassname">mir_eval.chord.</code><code class="descname">quality_to_bitmap</code><span class="sig-paren">(</span><em>quality</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.quality_to_bitmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bitmap for a given quality.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>quality</strong> : str</p>
<blockquote>
<div><p>Chord quality name.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bitmap</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Bitmap representation of this quality (12-dim).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.reduce_extended_quality">
<code class="descclassname">mir_eval.chord.</code><code class="descname">reduce_extended_quality</code><span class="sig-paren">(</span><em>quality</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.reduce_extended_quality" title="Permalink to this definition">¶</a></dt>
<dd><p>Map an extended chord quality to a simpler one, moving upper voices to
a set of scale degree extensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>quality</strong> : str</p>
<blockquote>
<div><p>Extended chord quality to reduce.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>base_quality</strong> : str</p>
<blockquote>
<div><p>New chord quality.</p>
</div></blockquote>
<p><strong>extensions</strong> : set</p>
<blockquote class="last">
<div><p>Scale degrees extensions for the quality.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.validate_chord_label">
<code class="descclassname">mir_eval.chord.</code><code class="descname">validate_chord_label</code><span class="sig-paren">(</span><em>chord_label</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.validate_chord_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for well-formedness of a chord label.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chord</strong> : str</p>
<blockquote class="last">
<div><p>Chord label to validate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.split">
<code class="descclassname">mir_eval.chord.</code><code class="descname">split</code><span class="sig-paren">(</span><em>chord_label</em>, <em>reduce_extended_chords=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.split" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Parse a chord label into its four constituent parts:</dt>
<dd><ul class="first last simple">
<li>root</li>
<li>quality shorthand</li>
<li>scale degrees</li>
<li>bass</li>
</ul>
</dd>
<dt>Note: Chords lacking quality AND interval information are major.</dt>
<dd><ul class="first last simple">
<li>If a quality is specified, it is returned.</li>
<li>If an interval is specified WITHOUT a quality, the quality field is
empty.</li>
</ul>
</dd>
</dl>
<p>Some examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="s1">&#39;C&#39;</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;maj&#39;</span><span class="p">,</span> <span class="p">{},</span> <span class="s1">&#39;1&#39;</span><span class="p">]</span>
<span class="s1">&#39;G#:min(*b3,*5)/5&#39;</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="s1">&#39;G#&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;*b3&#39;</span><span class="p">,</span> <span class="s1">&#39;*5&#39;</span><span class="p">},</span> <span class="s1">&#39;5&#39;</span><span class="p">]</span>
<span class="s1">&#39;A:(3)/6&#39;</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;3&#39;</span><span class="p">},</span> <span class="s1">&#39;6&#39;</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chord_label</strong> : str</p>
<blockquote>
<div><p>A chord label.</p>
</div></blockquote>
<p><strong>reduce_extended_chords</strong> : bool</p>
<blockquote>
<div><p>Whether to map the upper voicings of extended chords (9’s, 11’s, 13’s)
to semitone extensions. (Default value = False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>chord_parts</strong> : list</p>
<blockquote class="last">
<div><p>Split version of the chord label.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.join">
<code class="descclassname">mir_eval.chord.</code><code class="descname">join</code><span class="sig-paren">(</span><em>chord_root</em>, <em>quality=''</em>, <em>extensions=None</em>, <em>bass=''</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join the parts of a chord into a complete chord label.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chord_root</strong> : str</p>
<blockquote>
<div><p>Root pitch class of the chord, e.g. ‘C’, ‘Eb’</p>
</div></blockquote>
<p><strong>quality</strong> : str</p>
<blockquote>
<div><p>Quality of the chord, e.g. ‘maj’, ‘hdim7’
(Default value = ‘’)</p>
</div></blockquote>
<p><strong>extensions</strong> : list</p>
<blockquote>
<div><p>Any added or absent scaled degrees for this chord, e.g. [‘4’, ‘*3’]
(Default value = None)</p>
</div></blockquote>
<p><strong>bass</strong> : str</p>
<blockquote>
<div><p>Scale degree of the bass note, e.g. ‘5’.
(Default value = ‘’)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>chord_label</strong> : str</p>
<blockquote class="last">
<div><p>A complete chord label.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.encode">
<code class="descclassname">mir_eval.chord.</code><code class="descname">encode</code><span class="sig-paren">(</span><em>chord_label</em>, <em>reduce_extended_chords=False</em>, <em>strict_bass_intervals=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a chord label to numerical representations for evaluation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chord_label</strong> : str</p>
<blockquote>
<div><p>Chord label to encode.</p>
</div></blockquote>
<p><strong>reduce_extended_chords</strong> : bool</p>
<blockquote>
<div><p>Whether to map the upper voicings of extended chords (9’s, 11’s, 13’s)
to semitone extensions.
(Default value = False)</p>
</div></blockquote>
<p><strong>strict_bass_intervals</strong> : bool</p>
<blockquote>
<div><p>Whether to require that the bass scale degree is present in the chord.
(Default value = False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>root_number</strong> : int</p>
<blockquote>
<div><p>Absolute semitone of the chord’s root.</p>
</div></blockquote>
<p><strong>semitone_bitmap</strong> : np.ndarray, dtype=int</p>
<blockquote>
<div><p>12-dim vector of relative semitones in the chord spelling.</p>
</div></blockquote>
<p><strong>bass_number</strong> : int</p>
<blockquote class="last">
<div><p>Relative semitone of the chord’s bass note, e.g. 0=root, 7=fifth, etc.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.encode_many">
<code class="descclassname">mir_eval.chord.</code><code class="descname">encode_many</code><span class="sig-paren">(</span><em>chord_labels</em>, <em>reduce_extended_chords=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.encode_many" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a set of chord labels to numerical representations for sane
evaluation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chord_labels</strong> : list</p>
<blockquote>
<div><p>Set of chord labels to encode.</p>
</div></blockquote>
<p><strong>reduce_extended_chords</strong> : bool</p>
<blockquote>
<div><p>Whether to map the upper voicings of extended chords (9’s, 11’s, 13’s)
to semitone extensions.
(Default value = False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>root_number</strong> : np.ndarray, dtype=int</p>
<blockquote>
<div><p>Absolute semitone of the chord’s root.</p>
</div></blockquote>
<p><strong>interval_bitmap</strong> : np.ndarray, dtype=int</p>
<blockquote>
<div><p>12-dim vector of relative semitones in the given chord quality.</p>
</div></blockquote>
<p><strong>bass_number</strong> : np.ndarray, dtype=int</p>
<blockquote class="last">
<div><p>Relative semitones of the chord’s bass notes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.rotate_bitmap_to_root">
<code class="descclassname">mir_eval.chord.</code><code class="descname">rotate_bitmap_to_root</code><span class="sig-paren">(</span><em>bitmap</em>, <em>chord_root</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.rotate_bitmap_to_root" title="Permalink to this definition">¶</a></dt>
<dd><p>Circularly shift a relative bitmap to its asbolute pitch classes.</p>
<p>For clarity, the best explanation is an example. Given ‘G:Maj’, the root
and quality map are as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">root</span><span class="o">=</span><span class="mi">5</span>
<span class="n">quality</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Relative chord shape</span>
</pre></div>
</div>
<p>After rotating to the root, the resulting bitmap becomes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">abs_quality</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># G, B, and D</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bitmap</strong> : np.ndarray, shape=(12,)</p>
<blockquote>
<div><p>Bitmap of active notes, relative to the given root.</p>
</div></blockquote>
<p><strong>chord_root</strong> : int</p>
<blockquote>
<div><p>Absolute pitch class number.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bitmap</strong> : np.ndarray, shape=(12,)</p>
<blockquote class="last">
<div><p>Absolute bitmap of active pitch classes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.rotate_bitmaps_to_roots">
<code class="descclassname">mir_eval.chord.</code><code class="descname">rotate_bitmaps_to_roots</code><span class="sig-paren">(</span><em>bitmaps</em>, <em>roots</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.rotate_bitmaps_to_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Circularly shift a relative bitmaps to asbolute pitch classes.</p>
<p>See <a class="reference internal" href="#mir_eval.chord.rotate_bitmap_to_root" title="mir_eval.chord.rotate_bitmap_to_root"><code class="xref py py-func docutils literal"><span class="pre">rotate_bitmap_to_root()</span></code></a> for more information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bitmap</strong> : np.ndarray, shape=(N, 12)</p>
<blockquote>
<div><p>Bitmap of active notes, relative to the given root.</p>
</div></blockquote>
<p><strong>root</strong> : np.ndarray, shape=(N,)</p>
<blockquote>
<div><p>Absolute pitch class number.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bitmap</strong> : np.ndarray, shape=(N, 12)</p>
<blockquote class="last">
<div><p>Absolute bitmaps of active pitch classes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.validate">
<code class="descclassname">mir_eval.chord.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a comparison function look like
valid chord labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote class="last">
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.weighted_accuracy">
<code class="descclassname">mir_eval.chord.</code><code class="descname">weighted_accuracy</code><span class="sig-paren">(</span><em>comparisons</em>, <em>weights</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.weighted_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted accuracy of a list of chord comparisons.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>comparisons</strong> : np.ndarray</p>
<blockquote>
<div><p>List of chord comparison scores, in [0, 1] or -1</p>
</div></blockquote>
<p><strong>weights</strong> : np.ndarray</p>
<blockquote>
<div><p>Weights (not necessarily normalized) for each comparison.
This can be a list of interval durations</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>score</strong> : float</p>
<blockquote class="last">
<div><p>Weighted accuracy</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Here, we&#39;re using the &quot;thirds&quot; function to compare labels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># but any of the comparison functions would work.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">thirds</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.thirds">
<code class="descclassname">mir_eval.chord.</code><code class="descname">thirds</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.thirds" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along root &amp; third relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">thirds</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.thirds_inv">
<code class="descclassname">mir_eval.chord.</code><code class="descname">thirds_inv</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.thirds_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Score chords along root, third, &amp; bass relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">thirds_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.triads">
<code class="descclassname">mir_eval.chord.</code><code class="descname">triads</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.triads" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along triad (root &amp; quality to #5) relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">triads</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.triads_inv">
<code class="descclassname">mir_eval.chord.</code><code class="descname">triads_inv</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.triads_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Score chords along triad (root, quality to #5, &amp; bass) relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">triads_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.tetrads">
<code class="descclassname">mir_eval.chord.</code><code class="descname">tetrads</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.tetrads" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along tetrad (root &amp; full quality) relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">tetrads</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.tetrads_inv">
<code class="descclassname">mir_eval.chord.</code><code class="descname">tetrads_inv</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.tetrads_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along tetrad (root, full quality, &amp; bass) relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">tetrads_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.root">
<code class="descclassname">mir_eval.chord.</code><code class="descname">root</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.root" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords according to roots.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">root</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.mirex">
<code class="descclassname">mir_eval.chord.</code><code class="descname">mirex</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.mirex" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along MIREX rules.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">mirex</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.majmin">
<code class="descclassname">mir_eval.chord.</code><code class="descname">majmin</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.majmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along major-minor rules. Chords with qualities outside
Major/minor/no-chord are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">majmin</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.majmin_inv">
<code class="descclassname">mir_eval.chord.</code><code class="descname">majmin_inv</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.majmin_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along major-minor rules, with inversions. Chords with
qualities outside Major/minor/no-chord are ignored, and the bass note must
exist in the triad (bass in [1, 3, 5]).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">majmin_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.sevenths">
<code class="descclassname">mir_eval.chord.</code><code class="descname">sevenths</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.sevenths" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along MIREX ‘sevenths’ rules. Chords with qualities
outside [maj, maj7, 7, min, min7, N] are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">sevenths</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.sevenths_inv">
<code class="descclassname">mir_eval.chord.</code><code class="descname">sevenths_inv</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.sevenths_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along MIREX ‘sevenths’ rules. Chords with qualities
outside [maj, maj7, 7, min, min7, N] are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">sevenths_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.directional_hamming_distance">
<code class="descclassname">mir_eval.chord.</code><code class="descname">directional_hamming_distance</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>estimated_intervals</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.directional_hamming_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the directional hamming distance between reference and
estimated intervals as defined by <a class="footnote-reference" href="#harte2010towards" id="id5">[1]</a> and used for MIREX
‘OverSeg’, ‘UnderSeg’ and ‘MeanSeg’ measures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2), dtype=float</p>
<blockquote>
<div><p>Reference chord intervals to score against.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2), dtype=float</p>
<blockquote>
<div><p>Estimated chord intervals to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>directional hamming distance</strong> : float</p>
<blockquote class="last">
<div><p>directional hamming distance between reference intervals and
estimated intervals.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">overseg</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">directional_hamming_distance</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">underseg</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">directional_hamming_distance</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seg</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">overseg</span><span class="p">,</span> <span class="n">underseg</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.overseg">
<code class="descclassname">mir_eval.chord.</code><code class="descname">overseg</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>estimated_intervals</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.overseg" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the MIREX ‘OverSeg’ score.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2), dtype=float</p>
<blockquote>
<div><p>Reference chord intervals to score against.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2), dtype=float</p>
<blockquote>
<div><p>Estimated chord intervals to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oversegmentation score</strong> : float</p>
<blockquote class="last">
<div><p>Comparison score, in [0.0, 1.0], where 1.0 means no oversegmentation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">overseg</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.underseg">
<code class="descclassname">mir_eval.chord.</code><code class="descname">underseg</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>estimated_intervals</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.underseg" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the MIREX ‘UnderSeg’ score.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2), dtype=float</p>
<blockquote>
<div><p>Reference chord intervals to score against.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2), dtype=float</p>
<blockquote>
<div><p>Estimated chord intervals to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>undersegmentation score</strong> : float</p>
<blockquote class="last">
<div><p>Comparison score, in [0.0, 1.0], where 1.0 means no undersegmentation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">underseg</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.seg">
<code class="descclassname">mir_eval.chord.</code><code class="descname">seg</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>estimated_intervals</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.seg" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the MIREX ‘MeanSeg’ score.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2), dtype=float</p>
<blockquote>
<div><p>Reference chord intervals to score against.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2), dtype=float</p>
<blockquote>
<div><p>Estimated chord intervals to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>segmentation score</strong> : float</p>
<blockquote class="last">
<div><p>Comparison score, in [0.0, 1.0], where 1.0 means perfect segmentation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">seg</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.merge_chord_intervals">
<code class="descclassname">mir_eval.chord.</code><code class="descname">merge_chord_intervals</code><span class="sig-paren">(</span><em>intervals</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.merge_chord_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge consecutive chord intervals if they represent the same chord.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n, 2), dtype=float</p>
<blockquote>
<div><p>Chord intervals to be merged, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>Chord labels to be merged, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>merged_ivs</strong> : np.ndarray, shape=(k, 2), dtype=float</p>
<blockquote class="last">
<div><p>Merged chord intervals, k &lt;= n</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.evaluate">
<code class="descclassname">mir_eval.chord.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_labels</em>, <em>est_intervals</em>, <em>est_labels</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes weighted accuracy for all comparison functions for the given
reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>Reference chord intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>ref_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference chord labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated chord intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>est_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated chord labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.melody">
<span id="mir-eval-melody"></span><h3><a class="reference internal" href="#module-mir_eval.melody" title="mir_eval.melody"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.melody</span></code></a><a class="headerlink" href="#module-mir_eval.melody" title="Permalink to this headline">¶</a></h3>
<p>Melody extraction algorithms aim to produce a sequence of frequency values
corresponding to the pitch of the dominant melody from a musical
recording.  For evaluation, an estimated pitch series is evaluated against a
reference based on whether the voicing (melody present or not) and the pitch
is correct (within some tolerance).</p>
<dl class="docutils">
<dt>For a detailed explanation of the measures please refer to:</dt>
<dd>J. Salamon, E. Gomez, D. P. W. Ellis and G. Richard, “Melody Extraction
from Polyphonic Music Signals: Approaches, Applications and Challenges”,
IEEE Signal Processing Magazine, 31(2):118-134, Mar. 2014.</dd>
</dl>
<div class="section" id="id6">
<h4>Conventions<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>Melody annotations are assumed to be given in the format of a 1d array of
frequency values which are accompanied by a 1d array of times denoting when
each frequency value occurs.  In a reference melody time series, a frequency
value of 0 denotes “unvoiced”.  In a estimated melody time series, unvoiced
frames can be indicated either by 0 Hz or by a negative Hz value - negative
values represent the algorithm’s pitch estimate for frames it has determined as
unvoiced, in case they are in fact voiced.</p>
<p>Metrics are computed using a sequence of reference and estimated pitches in
cents and boolean voicing arrays, both of which are sampled to the same
timebase.  The function <a class="reference internal" href="#mir_eval.melody.to_cent_voicing" title="mir_eval.melody.to_cent_voicing"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.to_cent_voicing()</span></code></a> can be used to
convert a sequence of estimated and reference times and frequency values in Hz
to boolean voicing arrays and frequency arrays in the format required by the
metric functions.  By default, the convention is to resample the estimated
melody time series to the reference melody time series’ timebase.</p>
</div>
<div class="section" id="id7">
<h4>Metrics<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.melody.voicing_measures" title="mir_eval.melody.voicing_measures"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.voicing_measures()</span></code></a>: Voicing measures, including the
recall rate (proportion of frames labeled as melody frames in the reference
that are estimated as melody frames) and the false alarm
rate (proportion of frames labeled as non-melody in the reference that are
mistakenly estimated as melody frames)</li>
<li><a class="reference internal" href="#mir_eval.melody.raw_pitch_accuracy" title="mir_eval.melody.raw_pitch_accuracy"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.raw_pitch_accuracy()</span></code></a>: Raw Pitch Accuracy, which
computes the proportion of melody frames in the reference for which the
frequency is considered correct (i.e. within half a semitone of the reference
frequency)</li>
<li><a class="reference internal" href="#mir_eval.melody.raw_chroma_accuracy" title="mir_eval.melody.raw_chroma_accuracy"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.raw_chroma_accuracy()</span></code></a>: Raw Chroma Accuracy, where the
estimated and reference frequency sequences are mapped onto a single octave
before computing the raw pitch accuracy</li>
<li><a class="reference internal" href="#mir_eval.melody.overall_accuracy" title="mir_eval.melody.overall_accuracy"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.overall_accuracy()</span></code></a>: Overall Accuracy, which computes
the proportion of all frames correctly estimated by the algorithm, including
whether non-melody frames where labeled by the algorithm as non-melody</li>
</ul>
<dl class="function">
<dt id="mir_eval.melody.validate_voicing">
<code class="descclassname">mir_eval.melody.</code><code class="descname">validate_voicing</code><span class="sig-paren">(</span><em>ref_voicing</em>, <em>est_voicing</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.validate_voicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that voicing inputs to a metric are in the correct format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<p><strong>est_voicing</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Estimated boolean voicing array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.validate">
<code class="descclassname">mir_eval.melody.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>ref_voicing</em>, <em>ref_cent</em>, <em>est_voicing</em>, <em>est_cent</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that voicing and frequency arrays are well-formed.  To be used in
conjunction with <a class="reference internal" href="#mir_eval.melody.validate_voicing" title="mir_eval.melody.validate_voicing"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.validate_voicing()</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<p><strong>ref_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference pitch sequence in cents</p>
</div></blockquote>
<p><strong>est_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimated boolean voicing array</p>
</div></blockquote>
<p><strong>est_cent</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Estimate pitch sequence in cents</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.hz2cents">
<code class="descclassname">mir_eval.melody.</code><code class="descname">hz2cents</code><span class="sig-paren">(</span><em>freq_hz</em>, <em>base_frequency=10.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.hz2cents" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of frequency values in Hz to cents.
0 values are left in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>freq_hz</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of frequencies in Hz.</p>
</div></blockquote>
<p><strong>base_frequency</strong> : float</p>
<blockquote>
<div><p>Base frequency for conversion.
(Default value = 10.0)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cent</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Array of frequencies in cents, relative to base_frequency</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.freq_to_voicing">
<code class="descclassname">mir_eval.melody.</code><code class="descname">freq_to_voicing</code><span class="sig-paren">(</span><em>frequencies</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.freq_to_voicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from an array of frequency values to frequency array +
voice/unvoiced array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>frequencies</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of frequencies.  A frequency &lt;= 0 indicates “unvoiced”.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>frequencies</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of frequencies, all &gt;= 0.</p>
</div></blockquote>
<p><strong>voiced</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Boolean array, same length as frequencies,
which indicates voiced or unvoiced</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.constant_hop_timebase">
<code class="descclassname">mir_eval.melody.</code><code class="descname">constant_hop_timebase</code><span class="sig-paren">(</span><em>hop</em>, <em>end_time</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.constant_hop_timebase" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a time series from 0 to <code class="docutils literal"><span class="pre">end_time</span></code> with times spaced <code class="docutils literal"><span class="pre">hop</span></code>
apart</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>hop</strong> : float</p>
<blockquote>
<div><p>Spacing of samples in the time series</p>
</div></blockquote>
<p><strong>end_time</strong> : float</p>
<blockquote>
<div><p>Time series will span <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">end_time]</span></code></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>times</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Generated timebase</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.resample_melody_series">
<code class="descclassname">mir_eval.melody.</code><code class="descname">resample_melody_series</code><span class="sig-paren">(</span><em>times</em>, <em>frequencies</em>, <em>voicing</em>, <em>times_new</em>, <em>kind='linear'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.resample_melody_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Resamples frequency and voicing time series to a new timescale. Maintains
any zero (“unvoiced”) values in frequencies.</p>
<p>If <code class="docutils literal"><span class="pre">times</span></code> and <code class="docutils literal"><span class="pre">times_new</span></code> are equivalent, no resampling will be
performed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : np.ndarray</p>
<blockquote>
<div><p>Times of each frequency value</p>
</div></blockquote>
<p><strong>frequencies</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of frequency values, &gt;= 0</p>
</div></blockquote>
<p><strong>voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Boolean array which indicates voiced or unvoiced</p>
</div></blockquote>
<p><strong>times_new</strong> : np.ndarray</p>
<blockquote>
<div><p>Times to resample frequency and voicing sequences to</p>
</div></blockquote>
<p><strong>kind</strong> : str</p>
<blockquote>
<div><p>kind parameter to pass to scipy.interpolate.interp1d.
(Default value = ‘linear’)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>frequencies_resampled</strong> : np.ndarray</p>
<blockquote>
<div><p>Frequency array resampled to new timebase</p>
</div></blockquote>
<p><strong>voicing_resampled</strong> : np.ndarray, dtype=bool</p>
<blockquote class="last">
<div><p>Boolean voicing array resampled to new timebase</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.to_cent_voicing">
<code class="descclassname">mir_eval.melody.</code><code class="descname">to_cent_voicing</code><span class="sig-paren">(</span><em>ref_time</em>, <em>ref_freq</em>, <em>est_time</em>, <em>est_freq</em>, <em>base_frequency=10.0</em>, <em>hop=None</em>, <em>kind='linear'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.to_cent_voicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts reference and estimated time/frequency (Hz) annotations to sampled
frequency (cent)/voicing arrays.</p>
<p>A zero frequency indicates “unvoiced”.</p>
<p>A negative frequency indicates “Predicted as unvoiced, but if it’s voiced,
this is the frequency estimate”.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_time</strong> : np.ndarray</p>
<blockquote>
<div><p>Time of each reference frequency value</p>
</div></blockquote>
<p><strong>ref_freq</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of reference frequency values</p>
</div></blockquote>
<p><strong>est_time</strong> : np.ndarray</p>
<blockquote>
<div><p>Time of each estimated frequency value</p>
</div></blockquote>
<p><strong>est_freq</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of estimated frequency values</p>
</div></blockquote>
<p><strong>base_frequency</strong> : float</p>
<blockquote>
<div><p>Base frequency in Hz for conversion to cents
(Default value = 10.)</p>
</div></blockquote>
<p><strong>hop</strong> : float</p>
<blockquote>
<div><p>Hop size, in seconds, to resample,
default None which means use ref_time</p>
</div></blockquote>
<p><strong>kind</strong> : str</p>
<blockquote>
<div><p>kind parameter to pass to scipy.interpolate.interp1d.
(Default value = ‘linear’)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ref_voicing</strong> : np.ndarray, dtype=bool</p>
<blockquote>
<div><p>Resampled reference boolean voicing array</p>
</div></blockquote>
<p><strong>ref_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Resampled reference frequency (cent) array</p>
</div></blockquote>
<p><strong>est_voicing</strong> : np.ndarray, dtype=bool</p>
<blockquote>
<div><p>Resampled estimated boolean voicing array</p>
</div></blockquote>
<p><strong>est_cent</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Resampled estimated frequency (cent) array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.voicing_measures">
<code class="descclassname">mir_eval.melody.</code><code class="descname">voicing_measures</code><span class="sig-paren">(</span><em>ref_voicing</em>, <em>est_voicing</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.voicing_measures" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the voicing recall and false alarm rates given two voicing
indicator sequences, one as reference (truth) and the other as the estimate
(prediction).  The sequences must be of the same length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<p><strong>est_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimated boolean voicing array</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>vx_recall</strong> : float</p>
<blockquote>
<div><p>Voicing recall rate, the fraction of voiced frames in ref
indicated as voiced in est</p>
</div></blockquote>
<p><strong>vx_false_alarm</strong> : float</p>
<blockquote class="last">
<div><p>Voicing false alarm rate, the fraction of unvoiced frames in ref
indicated as voiced in est</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">to_cent_voicing</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_freq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">recall</span><span class="p">,</span> <span class="n">false_alarm</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">voicing_measures</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span>
<span class="gp">... </span>                                                       <span class="n">est_v</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.raw_pitch_accuracy">
<code class="descclassname">mir_eval.melody.</code><code class="descname">raw_pitch_accuracy</code><span class="sig-paren">(</span><em>ref_voicing</em>, <em>ref_cent</em>, <em>est_voicing</em>, <em>est_cent</em>, <em>cent_tolerance=50</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.raw_pitch_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw pitch accuracy given two pitch (frequency) sequences in
cents and matching voicing indicator sequences. The first pitch and voicing
arrays are treated as the reference (truth), and the second two as the
estimate (prediction).  All 4 sequences must be of the same length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<p><strong>ref_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference pitch sequence in cents</p>
</div></blockquote>
<p><strong>est_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimated boolean voicing array</p>
</div></blockquote>
<p><strong>est_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimate pitch sequence in cents</p>
</div></blockquote>
<p><strong>cent_tolerance</strong> : float</p>
<blockquote>
<div><p>Maximum absolute deviation for a cent value to be considerd correct
(Default value = 50)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw_pitch</strong> : float</p>
<blockquote class="last">
<div><p>Raw pitch accuracy, the fraction of voiced frames in ref_cent for
which est_cent provides a correct frequency values
(within cent_tolerance cents).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">to_cent_voicing</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_freq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw_pitch</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">raw_pitch_accuracy</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span>                                               <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.raw_chroma_accuracy">
<code class="descclassname">mir_eval.melody.</code><code class="descname">raw_chroma_accuracy</code><span class="sig-paren">(</span><em>ref_voicing</em>, <em>ref_cent</em>, <em>est_voicing</em>, <em>est_cent</em>, <em>cent_tolerance=50</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.raw_chroma_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw chroma accuracy given two pitch (frequency) sequences
in cents and matching voicing indicator sequences. The first pitch and
voicing arrays are treated as the reference (truth), and the second two as
the estimate (prediction).  All 4 sequences must be of the same length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<p><strong>ref_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference pitch sequence in cents</p>
</div></blockquote>
<p><strong>est_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimated boolean voicing array</p>
</div></blockquote>
<p><strong>est_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimate pitch sequence in cents</p>
</div></blockquote>
<p><strong>cent_tolerance</strong> : float</p>
<blockquote>
<div><p>Maximum absolute deviation for a cent value to be considered correct
(Default value = 50)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw_chroma</strong> : float</p>
<blockquote class="last">
<div><p>Raw chroma accuracy, the fraction of voiced frames in ref_cent for
which est_cent provides a correct frequency values (within
cent_tolerance cents), ignoring octave errors</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>J. Salamon, E. Gomez, D. P. W. Ellis and G. Richard, “Melody
Extraction from Polyphonic Music Signals: Approaches, Applications
and Challenges”, IEEE Signal Processing Magazine, 31(2):118-134,
Mar. 2014.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>G. E. Poliner, D. P. W. Ellis, A. F. Ehmann, E. Gomez, S.
Streich, and B. Ong. “Melody transcription from music audio:
Approaches and evaluation”, IEEE Transactions on Audio, Speech, and
Language Processing, 15(4):1247-1256, 2007.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">to_cent_voicing</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_freq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw_chroma</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">raw_chroma_accuracy</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.overall_accuracy">
<code class="descclassname">mir_eval.melody.</code><code class="descname">overall_accuracy</code><span class="sig-paren">(</span><em>ref_voicing</em>, <em>ref_cent</em>, <em>est_voicing</em>, <em>est_cent</em>, <em>cent_tolerance=50</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.overall_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the overall accuracy given two pitch (frequency) sequences in cents
and matching voicing indicator sequences. The first pitch and voicing
arrays are treated as the reference (truth), and the second two as the
estimate (prediction).  All 4 sequences must be of the same length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<p><strong>ref_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference pitch sequence in cents</p>
</div></blockquote>
<p><strong>est_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimated boolean voicing array</p>
</div></blockquote>
<p><strong>est_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimate pitch sequence in cents</p>
</div></blockquote>
<p><strong>cent_tolerance</strong> : float</p>
<blockquote>
<div><p>Maximum absolute deviation for a cent value to be considered correct
(Default value = 50)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>overall_accuracy</strong> : float</p>
<blockquote class="last">
<div><p>Overall accuracy, the total fraction of correctly estimates frames,
where provides a correct frequency values (within cent_tolerance
cents).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">to_cent_voicing</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_freq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">overall_accuracy</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">overall_accuracy</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span>                                                    <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.evaluate">
<code class="descclassname">mir_eval.melody.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>ref_time</em>, <em>ref_freq</em>, <em>est_time</em>, <em>est_freq</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate two melody (predominant f0) transcriptions, where the first is
treated as the reference (ground truth) and the second as the estimate to
be evaluated (prediction).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_time</strong> : np.ndarray</p>
<blockquote>
<div><p>Time of each reference frequency value</p>
</div></blockquote>
<p><strong>ref_freq</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of reference frequency values</p>
</div></blockquote>
<p><strong>est_time</strong> : np.ndarray</p>
<blockquote>
<div><p>Time of each estimated frequency value</p>
</div></blockquote>
<p><strong>est_freq</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of estimated frequency values</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.multipitch">
<span id="mir-eval-multipitch"></span><h3><a class="reference internal" href="#module-mir_eval.multipitch" title="mir_eval.multipitch"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.multipitch</span></code></a><a class="headerlink" href="#module-mir_eval.multipitch" title="Permalink to this headline">¶</a></h3>
<p>The goal of multiple f0 (multipitch) estimation and tracking is to identify
all of the active fundamental frequencies in each time frame in a complex music
signal.</p>
<div class="section" id="id10">
<h4>Conventions<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>Multipitch estimates are represented by a timebase and a corresponding list
of arrays of frequency estimates. Frequency estimates may have any number of
frequency values, including 0 (represented by an empty array). Time values are
in units of seconds and frequency estimates are in units of Hz.</p>
<p>The timebase of the estimate time series should ideally match the timebase of
the reference time series, but if this is not the case, the estimate time
series is resampled using a nearest neighbor interpolation to match the
estimate. Time values in the estimate time series that are outside of the range
of the reference time series are given null (empty array) frequencies.</p>
<p>By default, a frequency is “correct” if it is within 0.5 semitones of a
reference frequency. Frequency values are compared by first mapping them to
log-2 semitone space, where the distance between semitones is constant.
Chroma-wrapped frequency values are computed by taking the log-2 frequency
values modulo 12 to map them down to a single octave. A chroma-wrapped
frequency estimate is correct if it’s single-octave value is within 0.5
semitones of the single-octave reference frequency.</p>
<p>The metrics are based on those described in
<a class="footnote-reference" href="#poliner2007" id="id11">[4]</a> and <a class="footnote-reference" href="#bay2009" id="id12">[5]</a>.</p>
</div>
<div class="section" id="id13">
<h4>Metrics<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.multipitch.metrics" title="mir_eval.multipitch.metrics"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.multipitch.metrics()</span></code></a>: Precision, Recall, Accuracy,
Substitution, Miss, False Alarm, and Total Error scores based both on raw
frequency values and values mapped to a single octave (chroma).</li>
</ul>
</div>
<div class="section" id="id14">
<h4>References<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<table class="docutils footnote" frame="void" id="poliner2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[4]</a></td><td>G. E. Poliner, and D. P. W. Ellis, “A Discriminative
Model for Polyphonic Piano Transription”, EURASIP Journal on Advances in
Signal Processing, 2007(1):154-163, Jan. 2007.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="bay2009" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[5]</a></td><td>Bay, M., Ehmann, A. F., &amp; Downie, J. S. (2009). Evaluation of
Multiple-F0 Estimation and Tracking Systems. In ISMIR (pp. 315-320).</td></tr>
</tbody>
</table>
<dl class="function">
<dt id="mir_eval.multipitch.validate">
<code class="descclassname">mir_eval.multipitch.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>ref_time</em>, <em>ref_freqs</em>, <em>est_time</em>, <em>est_freqs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the time and frequency inputs are well-formed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_time</strong> : np.ndarray</p>
<blockquote>
<div><p>reference time stamps in seconds</p>
</div></blockquote>
<p><strong>ref_freqs</strong> : list of np.ndarray</p>
<blockquote>
<div><p>reference frequencies in Hz</p>
</div></blockquote>
<p><strong>est_time</strong> : np.ndarray</p>
<blockquote>
<div><p>estimate time stamps in seconds</p>
</div></blockquote>
<p><strong>est_freqs</strong> : list of np.ndarray</p>
<blockquote class="last">
<div><p>estimated frequencies in Hz</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.multipitch.resample_multipitch">
<code class="descclassname">mir_eval.multipitch.</code><code class="descname">resample_multipitch</code><span class="sig-paren">(</span><em>times</em>, <em>frequencies</em>, <em>target_times</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.resample_multipitch" title="Permalink to this definition">¶</a></dt>
<dd><p>Resamples multipitch time series to a new timescale. Values in
<code class="docutils literal"><span class="pre">target_times</span></code> outside the range of <code class="docutils literal"><span class="pre">times</span></code> return no pitch estimate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of time stamps</p>
</div></blockquote>
<p><strong>frequencies</strong> : list of np.ndarray</p>
<blockquote>
<div><p>List of np.ndarrays of frequency values</p>
</div></blockquote>
<p><strong>target_times</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of target time stamps</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>frequencies_resampled</strong> : list of numpy arrays</p>
<blockquote class="last">
<div><p>Frequency list of lists resampled to new timebase</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.multipitch.frequencies_to_midi">
<code class="descclassname">mir_eval.multipitch.</code><code class="descname">frequencies_to_midi</code><span class="sig-paren">(</span><em>frequencies</em>, <em>ref_frequency=440.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.frequencies_to_midi" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts frequencies to continuous MIDI values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>frequencies</strong> : list of np.ndarray</p>
<blockquote>
<div><p>Original frequency values</p>
</div></blockquote>
<p><strong>ref_frequency</strong> : float</p>
<blockquote>
<div><p>reference frequency in Hz.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>frequencies_midi</strong> : list of np.ndarray</p>
<blockquote class="last">
<div><p>Continuous MIDI frequency values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.multipitch.midi_to_chroma">
<code class="descclassname">mir_eval.multipitch.</code><code class="descname">midi_to_chroma</code><span class="sig-paren">(</span><em>frequencies_midi</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.midi_to_chroma" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap MIDI frequencies to a single octave (chroma).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>frequencies_midi</strong> : list of np.ndarray</p>
<blockquote>
<div><p>Continuous MIDI note frequency values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>frequencies_chroma</strong> : list of np.ndarray</p>
<blockquote class="last">
<div><p>Midi values wrapped to one octave.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.multipitch.compute_num_freqs">
<code class="descclassname">mir_eval.multipitch.</code><code class="descname">compute_num_freqs</code><span class="sig-paren">(</span><em>frequencies</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.compute_num_freqs" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the number of frequencies for each time point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>frequencies</strong> : list of np.ndarray</p>
<blockquote>
<div><p>Frequency values</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>num_freqs</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Number of frequencies at each time point.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.multipitch.compute_num_true_positives">
<code class="descclassname">mir_eval.multipitch.</code><code class="descname">compute_num_true_positives</code><span class="sig-paren">(</span><em>ref_freqs</em>, <em>est_freqs</em>, <em>window=0.5</em>, <em>chroma=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.compute_num_true_positives" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the number of true positives in an estimate given a reference.
A frequency is correct if it is within a quartertone of the
correct frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_freqs</strong> : list of np.ndarray</p>
<blockquote>
<div><p>reference frequencies (MIDI)</p>
</div></blockquote>
<p><strong>est_freqs</strong> : list of np.ndarray</p>
<blockquote>
<div><p>estimated frequencies (MIDI)</p>
</div></blockquote>
<p><strong>window</strong> : float</p>
<blockquote>
<div><p>Window size, in semitones</p>
</div></blockquote>
<p><strong>chroma</strong> : bool</p>
<blockquote>
<div><p>If True, computes distances modulo n.
If True, <code class="docutils literal"><span class="pre">ref_freqs</span></code> and <code class="docutils literal"><span class="pre">est_freqs</span></code> should be wrapped modulo n.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>true_positives</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Array the same length as ref_freqs containing the number of true
positives.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.multipitch.compute_accuracy">
<code class="descclassname">mir_eval.multipitch.</code><code class="descname">compute_accuracy</code><span class="sig-paren">(</span><em>true_positives</em>, <em>n_ref</em>, <em>n_est</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.compute_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute accuracy metrics.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>true_positives</strong> : np.ndarray</p>
<blockquote>
<div><p>Array containing the number of true positives at each time point.</p>
</div></blockquote>
<p><strong>n_ref</strong> : np.ndarray</p>
<blockquote>
<div><p>Array containing the number of reference frequencies at each time
point.</p>
</div></blockquote>
<p><strong>n_est</strong> : np.ndarray</p>
<blockquote>
<div><p>Array containing the number of estimate frequencies at each time point.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>precision</strong> : float</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">sum(true_positives)/sum(n_est)</span></code></p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">sum(true_positives)/sum(n_ref)</span></code></p>
</div></blockquote>
<p><strong>acc</strong> : float</p>
<blockquote class="last">
<div><p><code class="docutils literal"><span class="pre">sum(true_positives)/sum(n_est</span> <span class="pre">+</span> <span class="pre">n_ref</span> <span class="pre">-</span> <span class="pre">true_positives)</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.multipitch.compute_err_score">
<code class="descclassname">mir_eval.multipitch.</code><code class="descname">compute_err_score</code><span class="sig-paren">(</span><em>true_positives</em>, <em>n_ref</em>, <em>n_est</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.compute_err_score" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute error score metrics.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>true_positives</strong> : np.ndarray</p>
<blockquote>
<div><p>Array containing the number of true positives at each time point.</p>
</div></blockquote>
<p><strong>n_ref</strong> : np.ndarray</p>
<blockquote>
<div><p>Array containing the number of reference frequencies at each time
point.</p>
</div></blockquote>
<p><strong>n_est</strong> : np.ndarray</p>
<blockquote>
<div><p>Array containing the number of estimate frequencies at each time point.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>e_sub</strong> : float</p>
<blockquote>
<div><p>Substitution error</p>
</div></blockquote>
<p><strong>e_miss</strong> : float</p>
<blockquote>
<div><p>Miss error</p>
</div></blockquote>
<p><strong>e_fa</strong> : float</p>
<blockquote>
<div><p>False alarm error</p>
</div></blockquote>
<p><strong>e_tot</strong> : float</p>
<blockquote class="last">
<div><p>Total error</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.multipitch.metrics">
<code class="descclassname">mir_eval.multipitch.</code><code class="descname">metrics</code><span class="sig-paren">(</span><em>ref_time</em>, <em>ref_freqs</em>, <em>est_time</em>, <em>est_freqs</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.metrics" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute multipitch metrics. All metrics are computed at the ‘macro’ level
such that the frame true positive/false positive/false negative rates are
summed across time and the metrics are computed on the combined values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_time</strong> : np.ndarray</p>
<blockquote>
<div><p>Time of each reference frequency value</p>
</div></blockquote>
<p><strong>ref_freqs</strong> : list of np.ndarray</p>
<blockquote>
<div><p>List of np.ndarrays of reference frequency values</p>
</div></blockquote>
<p><strong>est_time</strong> : np.ndarray</p>
<blockquote>
<div><p>Time of each estimated frequency value</p>
</div></blockquote>
<p><strong>est_freqs</strong> : list of np.ndarray</p>
<blockquote>
<div><p>List of np.ndarrays of estimate frequency values</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>precision</strong> : float</p>
<blockquote>
<div><p>Precision (TP/(TP + FP))</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote>
<div><p>Recall (TP/(TP + FN))</p>
</div></blockquote>
<p><strong>accuracy</strong> : float</p>
<blockquote>
<div><p>Accuracy (TP/(TP + FP + FN))</p>
</div></blockquote>
<p><strong>e_sub</strong> : float</p>
<blockquote>
<div><p>Substitution error</p>
</div></blockquote>
<p><strong>e_miss</strong> : float</p>
<blockquote>
<div><p>Miss error</p>
</div></blockquote>
<p><strong>e_fa</strong> : float</p>
<blockquote>
<div><p>False alarm error</p>
</div></blockquote>
<p><strong>e_tot</strong> : float</p>
<blockquote>
<div><p>Total error</p>
</div></blockquote>
<p><strong>precision_chroma</strong> : float</p>
<blockquote>
<div><p>Chroma precision</p>
</div></blockquote>
<p><strong>recall_chroma</strong> : float</p>
<blockquote>
<div><p>Chroma recall</p>
</div></blockquote>
<p><strong>accuracy_chroma</strong> : float</p>
<blockquote>
<div><p>Chroma accuracy</p>
</div></blockquote>
<p><strong>e_sub_chroma</strong> : float</p>
<blockquote>
<div><p>Chroma substitution error</p>
</div></blockquote>
<p><strong>e_miss_chroma</strong> : float</p>
<blockquote>
<div><p>Chroma miss error</p>
</div></blockquote>
<p><strong>e_fa_chroma</strong> : float</p>
<blockquote>
<div><p>Chroma false alarm error</p>
</div></blockquote>
<p><strong>e_tot_chroma</strong> : float</p>
<blockquote class="last">
<div><p>Chroma total error</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freqs</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_ragged_time_series</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freqs</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_ragged_time_series</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metris_tuple</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">multipitch</span><span class="o">.</span><span class="n">metrics</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freqs</span><span class="p">,</span> <span class="n">est_time</span><span class="p">,</span> <span class="n">est_freqs</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.multipitch.evaluate">
<code class="descclassname">mir_eval.multipitch.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>ref_time</em>, <em>ref_freqs</em>, <em>est_time</em>, <em>est_freqs</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.multipitch.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate two multipitch (multi-f0) transcriptions, where the first is
treated as the reference (ground truth) and the second as the estimate to
be evaluated (prediction).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_time</strong> : np.ndarray</p>
<blockquote>
<div><p>Time of each reference frequency value</p>
</div></blockquote>
<p><strong>ref_freqs</strong> : list of np.ndarray</p>
<blockquote>
<div><p>List of np.ndarrays of reference frequency values</p>
</div></blockquote>
<p><strong>est_time</strong> : np.ndarray</p>
<blockquote>
<div><p>Time of each estimated frequency value</p>
</div></blockquote>
<p><strong>est_freqs</strong> : list of np.ndarray</p>
<blockquote>
<div><p>List of np.ndarrays of estimate frequency values</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_ragged_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_ragged_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">multipitch</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.onset">
<span id="mir-eval-onset"></span><h3><a class="reference internal" href="#module-mir_eval.onset" title="mir_eval.onset"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.onset</span></code></a><a class="headerlink" href="#module-mir_eval.onset" title="Permalink to this headline">¶</a></h3>
<p>The goal of an onset detection algorithm is to automatically determine when
notes are played in a piece of music.  The primary method used to evaluate
onset detectors is to first determine which estimated onsets are “correct”,
where correctness is defined as being within a small window of a reference
onset.</p>
<p>Based in part on this script:</p>
<blockquote>
<div><a class="reference external" href="https://github.com/CPJKU/onset_detection/blob/master/onset_evaluation.py">https://github.com/CPJKU/onset_detection/blob/master/onset_evaluation.py</a></div></blockquote>
<div class="section" id="id15">
<h4>Conventions<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>Onsets should be provided in the form of a 1-dimensional array of onset
times in seconds in increasing order.</p>
</div>
<div class="section" id="id16">
<h4>Metrics<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.onset.f_measure" title="mir_eval.onset.f_measure"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.onset.f_measure()</span></code></a>: Precision, Recall, and F-measure scores
based on the number of esimated onsets which are sufficiently close to
reference onsets.</li>
</ul>
<dl class="function">
<dt id="mir_eval.onset.validate">
<code class="descclassname">mir_eval.onset.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>reference_onsets</em>, <em>estimated_onsets</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.onset.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid onset time
arrays, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_onsets</strong> : np.ndarray</p>
<blockquote>
<div><p>reference onset locations, in seconds</p>
</div></blockquote>
<p><strong>estimated_onsets</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>estimated onset locations, in seconds</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.onset.f_measure">
<code class="descclassname">mir_eval.onset.</code><code class="descname">f_measure</code><span class="sig-paren">(</span><em>reference_onsets</em>, <em>estimated_onsets</em>, <em>window=0.05</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.onset.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the F-measure of correct vs incorrectly predicted onsets.
“Corectness” is determined over a small window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_onsets</strong> : np.ndarray</p>
<blockquote>
<div><p>reference onset locations, in seconds</p>
</div></blockquote>
<p><strong>estimated_onsets</strong> : np.ndarray</p>
<blockquote>
<div><p>estimated onset locations, in seconds</p>
</div></blockquote>
<p><strong>window</strong> : float</p>
<blockquote>
<div><p>Window size, in seconds
(Default value = .05)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_measure</strong> : float</p>
<blockquote>
<div><p>2*precision*recall/(precision + recall)</p>
</div></blockquote>
<p><strong>precision</strong> : float</p>
<blockquote>
<div><p>(# true positives)/(# true positives + # false positives)</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote class="last">
<div><p>(# true positives)/(# true positives + # false negatives)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">f_measure</span><span class="p">(</span><span class="n">reference_onsets</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">estimated_onsets</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.onset.evaluate">
<code class="descclassname">mir_eval.onset.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>reference_onsets</em>, <em>estimated_onsets</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.onset.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_onsets</strong> : np.ndarray</p>
<blockquote>
<div><p>reference onset locations, in seconds</p>
</div></blockquote>
<p><strong>estimated_onsets</strong> : np.ndarray</p>
<blockquote>
<div><p>estimated onset locations, in seconds</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_onsets</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">estimated_onsets</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.pattern">
<span id="mir-eval-pattern"></span><h3><a class="reference internal" href="#module-mir_eval.pattern" title="mir_eval.pattern"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.pattern</span></code></a><a class="headerlink" href="#module-mir_eval.pattern" title="Permalink to this headline">¶</a></h3>
<p>Pattern discovery involves the identification of musical patterns (i.e. short
fragments or melodic ideas that repeat at least twice) both from audio and
symbolic representations.  The metrics used to evaluate pattern discovery
systems attempt to quantify the ability of the algorithm to not only determine
the present patterns in a piece, but also to find all of their occurrences.</p>
<dl class="docutils">
<dt>Based on the methods described here:</dt>
<dd>T. Collins. MIREX task: Discovery of repeated themes &amp; sections.
<a class="reference external" href="http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections">http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections</a>,
2013.</dd>
</dl>
<div class="section" id="id17">
<h4>Conventions<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>The input format can be automatically generated by calling
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a>.  This format is a list of a list of
tuples.  The first list collections patterns, each of which is a list of
occurences, and each occurrence is a list of MIDI onset tuples of
<code class="docutils literal"><span class="pre">(onset_time,</span> <span class="pre">mid_note)</span></code></p>
<p>A pattern is a list of occurrences. The first occurrence must be the prototype
of that pattern (i.e. the most representative of all the occurrences).  An
occurrence is a list of tuples containing the onset time and the midi note
number.</p>
</div>
<div class="section" id="id18">
<h4>Metrics<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.pattern.standard_FPR" title="mir_eval.pattern.standard_FPR"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.standard_FPR()</span></code></a>: Strict metric in order to find the
possibly transposed patterns of exact length. This is the only metric that
considers transposed patterns.</li>
<li><a class="reference internal" href="#mir_eval.pattern.establishment_FPR" title="mir_eval.pattern.establishment_FPR"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.establishment_FPR()</span></code></a>: Evaluates the amount of patterns
that were successfully identified by the estimated results, no matter how
many occurrences they found.  In other words, this metric captures how the
algorithm successfully <em>established</em> that a pattern repeated at least twice,
and this pattern is also found in the reference annotation.</li>
<li><a class="reference internal" href="#mir_eval.pattern.occurrence_FPR" title="mir_eval.pattern.occurrence_FPR"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.occurrence_FPR()</span></code></a>: Evaluation of how well an estimation
can effectively identify all the occurrences of the found patterns,
independently of how many patterns have been discovered. This metric has a
threshold parameter that indicates how similar two occurrences must be in
order to be considered equal.  In MIREX, this evaluation is run twice, with
thresholds .75 and .5.</li>
<li><a class="reference internal" href="#mir_eval.pattern.three_layer_FPR" title="mir_eval.pattern.three_layer_FPR"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.three_layer_FPR()</span></code></a>: Aims to evaluate the general
similarity between the reference and the estimations, combining both the
establishment of patterns and the retrieval of its occurrences in a single F1
score.</li>
<li><a class="reference internal" href="#mir_eval.pattern.first_n_three_layer_P" title="mir_eval.pattern.first_n_three_layer_P"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.first_n_three_layer_P()</span></code></a>: Computes the three-layer
precision for the first N patterns only in order to measure the ability of
the algorithm to sort the identified patterns based on their relevance.</li>
<li><a class="reference internal" href="#mir_eval.pattern.first_n_target_proportion_R" title="mir_eval.pattern.first_n_target_proportion_R"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.first_n_target_proportion_R()</span></code></a>: Computes the target
proportion recall for the first N patterns only in order to measure the
ability of the algorithm to sort the identified patterns based on their
relevance.</li>
</ul>
<dl class="function">
<dt id="mir_eval.pattern.validate">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>reference_patterns</em>, <em>estimated_patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid pattern
lists, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns using the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>estimated_patterns</strong> : list</p>
<blockquote class="last">
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.standard_FPR">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">standard_FPR</code><span class="sig-paren">(</span><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>tol=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.standard_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard F1 Score, Precision and Recall.</p>
<p>This metric checks if the prototype patterns of the reference match
possible translated patterns in the prototype patterns of the estimations.
Since the sizes of these prototypes must be equal, this metric is quite
restictive and it tends to be 0 in most of 2013 MIREX results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns using the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>estimated_patterns</strong> : list</p>
<blockquote>
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
<p><strong>tol</strong> : float</p>
<blockquote>
<div><p>Tolerance level when comparing reference against estimation.
Default parameter is the one found in the original matlab code by
Tom Collins used for MIREX 2013.
(Default value = 1e-5)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_measure</strong> : float</p>
<blockquote>
<div><p>The standard F1 Score</p>
</div></blockquote>
<p><strong>precision</strong> : float</p>
<blockquote>
<div><p>The standard Precision</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote class="last">
<div><p>The standard Recall</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">standard_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span> <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.establishment_FPR">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">establishment_FPR</code><span class="sig-paren">(</span><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>similarity_metric='cardinality_score'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.establishment_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Establishment F1 Score, Precision and Recall.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>estimated_patterns</strong> : list</p>
<blockquote>
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
<p><strong>similarity_metric</strong> : str</p>
<blockquote>
<div><p>A string representing the metric to be used when computing the
similarity matrix. Accepted values:</p>
<blockquote>
<div><ul class="simple">
<li>“cardinality_score”: Count of the intersection
between occurrences.</li>
</ul>
</div></blockquote>
<p>(Default value = “cardinality_score”)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_measure</strong> : float</p>
<blockquote>
<div><p>The establishment F1 Score</p>
</div></blockquote>
<p><strong>precision</strong> : float</p>
<blockquote>
<div><p>The establishment Precision</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote class="last">
<div><p>The establishment Recall</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">establishment_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="gp">... </span>                                             <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.occurrence_FPR">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">occurrence_FPR</code><span class="sig-paren">(</span><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>thres=0.75</em>, <em>similarity_metric='cardinality_score'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.occurrence_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Establishment F1 Score, Precision and Recall.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>estimated_patterns</strong> : list</p>
<blockquote>
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
<p><strong>thres</strong> : float</p>
<blockquote>
<div><p>How similar two occcurrences must be in order to be considered
equal
(Default value = .75)</p>
</div></blockquote>
<p><strong>similarity_metric</strong> : str</p>
<blockquote>
<div><p>A string representing the metric to be used
when computing the similarity matrix. Accepted values:</p>
<blockquote>
<div><ul class="simple">
<li>“cardinality_score”: Count of the intersection
between occurrences.</li>
</ul>
</div></blockquote>
<p>(Default value = “cardinality_score”)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_measure</strong> : float</p>
<blockquote>
<div><p>The establishment F1 Score</p>
</div></blockquote>
<p><strong>precision</strong> : float</p>
<blockquote>
<div><p>The establishment Precision</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote class="last">
<div><p>The establishment Recall</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">occurrence_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="gp">... </span>                                          <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.three_layer_FPR">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">three_layer_FPR</code><span class="sig-paren">(</span><em>reference_patterns</em>, <em>estimated_patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.three_layer_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Three Layer F1 Score, Precision and Recall. As described by Meridith.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>estimated_patterns</strong> : list</p>
<blockquote>
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_measure</strong> : float</p>
<blockquote>
<div><p>The three-layer F1 Score</p>
</div></blockquote>
<p><strong>precision</strong> : float</p>
<blockquote>
<div><p>The three-layer Precision</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote class="last">
<div><p>The three-layer Recall</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">three_layer_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.first_n_three_layer_P">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">first_n_three_layer_P</code><span class="sig-paren">(</span><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.first_n_three_layer_P" title="Permalink to this definition">¶</a></dt>
<dd><p>First n three-layer precision.</p>
<p>This metric is basically the same as the three-layer FPR but it is only
applied to the first n estimated patterns, and it only returns the
precision. In MIREX and typically, n = 5.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>estimated_patterns</strong> : list</p>
<blockquote>
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p>Number of patterns to consider from the estimated results, in
the order they appear in the matrix
(Default value = 5)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>precision</strong> : float</p>
<blockquote class="last">
<div><p>The first n three-layer Precision</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">first_n_three_layer_P</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_patterns</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.first_n_target_proportion_R">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">first_n_target_proportion_R</code><span class="sig-paren">(</span><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.first_n_target_proportion_R" title="Permalink to this definition">¶</a></dt>
<dd><p>First n target proportion establishment recall metric.</p>
<p>This metric is similar is similar to the establishment FPR score, but it
only takes into account the first n estimated patterns and it only
outputs the Recall value of it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>estimated_patterns</strong> : list</p>
<blockquote>
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p>Number of patterns to consider from the estimated results, in
the order they appear in the matrix.
(Default value = 5)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>recall</strong> : float</p>
<blockquote class="last">
<div><p>The first n target proportion Recall.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">first_n_target_proportion_R</span><span class="p">(</span>
<span class="gp">... </span>                                <span class="n">ref_patterns</span><span class="p">,</span> <span class="n">est_patterns</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.evaluate">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>ref_patterns</em>, <em>est_patterns</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Load data and perform the evaluation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>est_patterns</strong> : list</p>
<blockquote>
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span> <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.segment">
<span id="mir-eval-segment"></span><h3><a class="reference internal" href="#module-mir_eval.segment" title="mir_eval.segment"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.segment</span></code></a><a class="headerlink" href="#module-mir_eval.segment" title="Permalink to this headline">¶</a></h3>
<p>Evaluation criteria for structural segmentation fall into two categories:
boundary annotation and structural annotation.  Boundary annotation is the task
of predicting the times at which structural changes occur, such as when a verse
transitions to a refrain.  Metrics for boundary annotation compare estimated
segment boundaries to reference boundaries.  Structural annotation is the task
of assigning labels to detected segments.  The estimated labels may be
arbitrary strings - such as A, B, C, - and they need not describe functional
concepts.  Metrics for structural annotation are similar to those used for
clustering data.</p>
<div class="section" id="id19">
<h4>Conventions<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<p>Both boundary and structural annotation metrics require two dimensional arrays
with two columns, one for boundary start times and one for boundary end times.
Structural annotation further require lists of reference and estimated segment
labels which must have a length which is equal to the number of rows in the
corresponding list of boundary edges.  In both tasks, we assume that
annotations express a partitioning of the track into intervals.  The function
<a class="reference internal" href="#mir_eval.util.adjust_intervals" title="mir_eval.util.adjust_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.util.adjust_intervals()</span></code></a> can be used to pad or crop the segment
boundaries to span the duration of the entire track.</p>
</div>
<div class="section" id="id20">
<h4>Metrics<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.segment.detection" title="mir_eval.segment.detection"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.detection()</span></code></a>: An estimated boundary is considered
correct if it falls within a window around a reference boundary
<a class="footnote-reference" href="#turnbull2007" id="id21">[6]</a></li>
<li><a class="reference internal" href="#mir_eval.segment.deviation" title="mir_eval.segment.deviation"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.deviation()</span></code></a>: Computes the median absolute time
difference from a reference boundary to its nearest estimated boundary, and
vice versa <a class="footnote-reference" href="#turnbull2007" id="id22">[6]</a></li>
<li><a class="reference internal" href="#mir_eval.segment.pairwise" title="mir_eval.segment.pairwise"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.pairwise()</span></code></a>: For classifying pairs of sampled time
instants as belonging to the same structural component <a class="footnote-reference" href="#levy2008" id="id23">[7]</a></li>
<li><a class="reference internal" href="#mir_eval.segment.rand_index" title="mir_eval.segment.rand_index"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.rand_index()</span></code></a>: Clusters reference and estimated
annotations and compares them by the Rand Index</li>
<li><a class="reference internal" href="#mir_eval.segment.ari" title="mir_eval.segment.ari"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.ari()</span></code></a>: Computes the Rand index, adjusted for chance</li>
<li><a class="reference internal" href="#mir_eval.segment.nce" title="mir_eval.segment.nce"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.nce()</span></code></a>: Interprets sampled reference and estimated
labels as samples of random variables <img class="math" src="_images/math/2af274bc15771abe7ab2fabc7d4c8110b812e490.png" alt="Y_R, Y_E"/> from which the
conditional entropy of <img class="math" src="_images/math/ebf46721a74c79e6f9dc06f68bc04bbc7bd4fa70.png" alt="Y_R"/> given <img class="math" src="_images/math/69f9c97fedf21dbfc131460c5e745fa01ef130cc.png" alt="Y_E"/> (Under-Segmentation) and
<img class="math" src="_images/math/69f9c97fedf21dbfc131460c5e745fa01ef130cc.png" alt="Y_E"/> given <img class="math" src="_images/math/ebf46721a74c79e6f9dc06f68bc04bbc7bd4fa70.png" alt="Y_R"/> (Over-Segmentation) are estimated
<a class="footnote-reference" href="#lukashevich2008" id="id24">[8]</a></li>
<li><a class="reference internal" href="#mir_eval.segment.mutual_information" title="mir_eval.segment.mutual_information"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.mutual_information()</span></code></a>: Computes the standard,
normalized, and adjusted mutual information of sampled reference and
estimated segments</li>
<li><a class="reference internal" href="#mir_eval.segment.vmeasure" title="mir_eval.segment.vmeasure"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.vmeasure()</span></code></a>: Computes the V-Measure, which is similar
to the conditional entropy metrics, but uses the marginal distributions
as normalization rather than the maximum entropy distribution
<a class="footnote-reference" href="#rosenberg2007" id="id25">[9]</a></li>
</ul>
</div>
<div class="section" id="id26">
<h4>References<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><table class="docutils footnote" frame="void" id="turnbull2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td><em>(<a class="fn-backref" href="#id21">1</a>, <a class="fn-backref" href="#id22">2</a>)</em> Turnbull, D., Lanckriet, G. R., Pampalk, E.,
&amp; Goto, M.  A Supervised Approach for Detecting Boundaries in Music
Using Difference Features and Boosting. In ISMIR (pp. 51-54).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="levy2008" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[7]</a></td><td>Levy, M., &amp; Sandler, M.
Structural segmentation of musical audio by constrained clustering.
IEEE transactions on audio, speech, and language processing, 16(2),
318-326.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="lukashevich2008" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[8]</a></td><td>Lukashevich, H. M.
Towards Quantitative Measures of Evaluating Song Segmentation.
In ISMIR (pp. 375-380).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="rosenberg2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[9]</a></td><td>Rosenberg, A., &amp; Hirschberg, J.
V-Measure: A Conditional Entropy-Based External Cluster Evaluation
Measure.
In EMNLP-CoNLL (Vol. 7, pp. 410-420).</td></tr>
</tbody>
</table>
</div></blockquote>
<dl class="function">
<dt id="mir_eval.segment.validate_boundary">
<code class="descclassname">mir_eval.segment.</code><code class="descname">validate_boundary</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>estimated_intervals</em>, <em>trim</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.validate_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a segment boundary estimation
metric (i.e. one that only takes in segment intervals) look like valid
segment times, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>trim</strong> : bool</p>
<blockquote class="last">
<div><p>will the start and end events be trimmed?</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.validate_structure">
<code class="descclassname">mir_eval.segment.</code><code class="descname">validate_structure</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.validate_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a structure estimation metric (i.e.
one that takes in both segment boundaries and their labels) look like valid
segment times and labels, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>reference_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, shape=(m,)</p>
<blockquote class="last">
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.detection">
<code class="descclassname">mir_eval.segment.</code><code class="descname">detection</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>estimated_intervals</em>, <em>window=0.5</em>, <em>beta=1.0</em>, <em>trim=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.detection" title="Permalink to this definition">¶</a></dt>
<dd><p>Boundary detection hit-rate.</p>
<p>A hit is counted whenever an reference boundary is within <code class="docutils literal"><span class="pre">window</span></code> of a
estimated boundary.  Note that each boundary is matched at most once: this
is achieved by computing the size of a maximal matching between reference
and estimated boundary points, subject to the window constraint.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>window</strong> : float &gt; 0</p>
<blockquote>
<div><p>size of the window of ‘correctness’ around ground-truth beats
(in seconds)
(Default value = 0.5)</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>weighting constant for F-measure.
(Default value = 1.0)</p>
</div></blockquote>
<p><strong>trim</strong> : boolean</p>
<blockquote>
<div><p>if <code class="docutils literal"><span class="pre">True</span></code>, the first and last boundary times are ignored.
Typically, these denote start (0) and end-markers.
(Default value = False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>precision</strong> : float</p>
<blockquote>
<div><p>precision of estimated predictions</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote>
<div><p>recall of reference reference boundaries</p>
</div></blockquote>
<p><strong>f_measure</strong> : float</p>
<blockquote class="last">
<div><p>F-measure (weighted harmonic mean of <code class="docutils literal"><span class="pre">precision</span></code> and <code class="docutils literal"><span class="pre">recall</span></code>)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># With 0.5s windowing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P05</span><span class="p">,</span> <span class="n">R05</span><span class="p">,</span> <span class="n">F05</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">detection</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">window</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># With 3s windowing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P3</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">F3</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">detection</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">window</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Ignoring hits for the beginning and end of track</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">detection</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">window</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">trim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.deviation">
<code class="descclassname">mir_eval.segment.</code><code class="descname">deviation</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>estimated_intervals</em>, <em>trim=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.deviation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median deviations between reference
and estimated boundary times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>trim</strong> : boolean</p>
<blockquote>
<div><p>if <code class="docutils literal"><span class="pre">True</span></code>, the first and last intervals are ignored.
Typically, these denote start (0.0) and end-of-track markers.
(Default value = False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>reference_to_estimated</strong> : float</p>
<blockquote>
<div><p>median time from each reference boundary to the
closest estimated boundary</p>
</div></blockquote>
<p><strong>estimated_to_reference</strong> : float</p>
<blockquote class="last">
<div><p>median time from each estimated boundary to the
closest reference boundary</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r_to_e</span><span class="p">,</span> <span class="n">e_to_r</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">deviation</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                             <span class="n">est_intervals</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.pairwise">
<code class="descclassname">mir_eval.segment.</code><code class="descname">pairwise</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-clustering segmentation evaluation by pair-wise agreement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>reference_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>frame_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>beta value for F-measure
(Default value = 1.0)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>precision</strong> : float &gt; 0</p>
<blockquote>
<div><p>Precision of detecting whether frames belong in the same cluster</p>
</div></blockquote>
<p><strong>recall</strong> : float &gt; 0</p>
<blockquote>
<div><p>Recall of detecting whether frames belong in the same cluster</p>
</div></blockquote>
<p><strong>f</strong> : float &gt; 0</p>
<blockquote class="last">
<div><p>F-measure of detecting whether frames belong in the same cluster</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">pairwise</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                   <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                                   <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                   <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.rand_index">
<code class="descclassname">mir_eval.segment.</code><code class="descname">rand_index</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.rand_index" title="Permalink to this definition">¶</a></dt>
<dd><p>(Non-adjusted) Rand index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>reference_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>frame_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>beta value for F-measure
(Default value = 1.0)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rand_index</strong> : float &gt; 0</p>
<blockquote class="last">
<div><p>Rand index</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rand_index</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">rand_index</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.ari">
<code class="descclassname">mir_eval.segment.</code><code class="descname">ari</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.ari" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjusted Rand Index (ARI) for frame clustering segmentation evaluation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>reference_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>frame_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ari_score</strong> : float &gt; 0</p>
<blockquote class="last">
<div><p>Adjusted Rand index between segmentations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ari_score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">ari</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.mutual_information">
<code class="descclassname">mir_eval.segment.</code><code class="descname">mutual_information</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.mutual_information" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-clustering segmentation: mutual information metrics.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>reference_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>frame_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>MI</strong> : float &gt; 0</p>
<blockquote>
<div><p>Mutual information between segmentations</p>
</div></blockquote>
<p><strong>AMI</strong> : float</p>
<blockquote>
<div><p>Adjusted mutual information between segmentations.</p>
</div></blockquote>
<p><strong>NMI</strong> : float &gt; 0</p>
<blockquote class="last">
<div><p>Normalize mutual information between segmentations</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mi</span><span class="p">,</span> <span class="n">ami</span><span class="p">,</span> <span class="n">nmi</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                     <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                                     <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                     <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.nce">
<code class="descclassname">mir_eval.segment.</code><code class="descname">nce</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em>, <em>beta=1.0</em>, <em>marginal=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.nce" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-clustering segmentation: normalized conditional entropy</p>
<p>Computes cross-entropy of cluster assignment, normalized by the
max-entropy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>reference_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>frame_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>beta for F-measure
(Default value = 1.0)</p>
</div></blockquote>
<p><strong>marginal</strong> : bool</p>
<blockquote>
<div><p>If <cite>False</cite>, normalize conditional entropy by uniform entropy.
If <cite>True</cite>, normalize conditional entropy by the marginal entropy.
(Default value = False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">S_over</p>
<blockquote>
<div><p>Over-clustering score:</p>
<ul class="simple">
<li>For <cite>marginal=False</cite>, <code class="docutils literal"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_est</span> <span class="pre">|</span> <span class="pre">y_ref)</span> <span class="pre">/</span> <span class="pre">log(|y_est|)</span></code></li>
<li>For <cite>marginal=True</cite>, <code class="docutils literal"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_est</span> <span class="pre">|</span> <span class="pre">y_ref)</span> <span class="pre">/</span> <span class="pre">H(y_est)</span></code></li>
</ul>
<p>If <cite>|y_est|==1</cite>, then <cite>S_over</cite> will be 0.</p>
</div></blockquote>
<p>S_under</p>
<blockquote>
<div><p>Under-clustering score:</p>
<ul class="simple">
<li>For <cite>marginal=False</cite>, <code class="docutils literal"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_ref</span> <span class="pre">|</span> <span class="pre">y_est)</span> <span class="pre">/</span> <span class="pre">log(|y_ref|)</span></code></li>
<li>For <cite>marginal=True</cite>, <code class="docutils literal"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_ref</span> <span class="pre">|</span> <span class="pre">y_est)</span> <span class="pre">/</span> <span class="pre">H(y_ref)</span></code></li>
</ul>
<p>If <cite>|y_ref|==1</cite>, then <cite>S_under</cite> will be 0.</p>
</div></blockquote>
<p>S_F</p>
<blockquote class="last">
<div><p>F-measure for (S_over, S_under)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_over</span><span class="p">,</span> <span class="n">S_under</span><span class="p">,</span> <span class="n">S_F</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">nce</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.vmeasure">
<code class="descclassname">mir_eval.segment.</code><code class="descname">vmeasure</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.vmeasure" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-clustering segmentation: v-measure</p>
<p>Computes cross-entropy of cluster assignment, normalized by the
marginal-entropy.</p>
<p>This is equivalent to <cite>nce(…, marginal=True)</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>reference_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>frame_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>beta for F-measure
(Default value = 1.0)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">V_precision</p>
<blockquote>
<div><p>Over-clustering score:
<code class="docutils literal"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_est</span> <span class="pre">|</span> <span class="pre">y_ref)</span> <span class="pre">/</span> <span class="pre">H(y_est)</span></code></p>
<p>If <cite>|y_est|==1</cite>, then <cite>V_precision</cite> will be 0.</p>
</div></blockquote>
<p>V_recall</p>
<blockquote>
<div><p>Under-clustering score:
<code class="docutils literal"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_ref</span> <span class="pre">|</span> <span class="pre">y_est)</span> <span class="pre">/</span> <span class="pre">H(y_ref)</span></code></p>
<p>If <cite>|y_ref|==1</cite>, then <cite>V_recall</cite> will be 0.</p>
</div></blockquote>
<p>V_F</p>
<blockquote class="last">
<div><p>F-measure for (V_precision, V_recall)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">V_precision</span><span class="p">,</span> <span class="n">V_recall</span><span class="p">,</span> <span class="n">V_F</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">vmeasure</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                         <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                                         <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                         <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.evaluate">
<code class="descclassname">mir_eval.segment.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_labels</em>, <em>est_intervals</em>, <em>est_labels</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>ref_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>est_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.hierarchy">
<span id="mir-eval-hierarchy"></span><h3><a class="reference internal" href="#module-mir_eval.hierarchy" title="mir_eval.hierarchy"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.hierarchy</span></code></a><a class="headerlink" href="#module-mir_eval.hierarchy" title="Permalink to this headline">¶</a></h3>
<p>Evaluation criteria for hierarchical structure analysis.</p>
<p>Hierarchical structure analysis seeks to annotate a track with a nested
decomposition of the temporal elements of the piece, effectively providing
a kind of “parse tree” of the composition.  Unlike the flat segmentation
metrics defined in <a class="reference internal" href="#module-mir_eval.segment" title="mir_eval.segment"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.segment</span></code></a>, which can only encode one level of
analysis, hierarchical annotations expose the relationships between short
segments and the larger compositional elements to which they belong.</p>
<div class="section" id="id27">
<h4>Conventions<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<p>Annotations are assumed to take the form of an ordered list of segmentations.
As in the <a class="reference internal" href="#module-mir_eval.segment" title="mir_eval.segment"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.segment</span></code></a> metrics, each segmentation itself consists of
an n-by-2 array of interval times, so that the <code class="docutils literal"><span class="pre">i</span></code> th segment spans time
<code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">0]</span></code> to <code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">1]</span></code>.</p>
<p>Hierarchical annotations are ordered by increasing specificity, so that the
first segmentation should contain the fewest segments, and the last
segmentation contains the most.</p>
</div>
<div class="section" id="id28">
<h4>Metrics<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.hierarchy.tmeasure" title="mir_eval.hierarchy.tmeasure"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.hierarchy.tmeasure()</span></code></a>: Precision, recall, and F-measure of
triplet-based frame accuracy for boundary detection.</li>
<li><a class="reference internal" href="#mir_eval.hierarchy.lmeasure" title="mir_eval.hierarchy.lmeasure"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.hierarchy.lmeasure()</span></code></a>: Precision, recall, and F-measure of
triplet-based frame accuracy for segment labeling.</li>
</ul>
</div>
<div class="section" id="id29">
<h4>References<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><table class="docutils footnote" frame="void" id="mcfee2015" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[10]</td><td>Brian McFee, Oriol Nieto, and Juan P. Bello.
“Hierarchical evaluation of segment boundary detection”,
International Society for Music Information Retrieval (ISMIR) conference,
2015.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mcfee2017" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[11]</td><td>Brian McFee, Oriol Nieto, Morwaread Farbood, and
Juan P. Bello.
“Evaluating hierarchical structure in music annotations”,
Frontiers in Psychology, 2017.</td></tr>
</tbody>
</table>
</div></blockquote>
<dl class="function">
<dt id="mir_eval.hierarchy.validate_hier_intervals">
<code class="descclassname">mir_eval.hierarchy.</code><code class="descname">validate_hier_intervals</code><span class="sig-paren">(</span><em>intervals_hier</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.hierarchy.validate_hier_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate a hierarchical segment annotation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals_hier</strong> : ordered list of segmentations</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>If any segmentation does not span the full duration of the top-level
segmentation.</p>
<p>If any segmentation does not start at 0.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.hierarchy.tmeasure">
<code class="descclassname">mir_eval.hierarchy.</code><code class="descname">tmeasure</code><span class="sig-paren">(</span><em>reference_intervals_hier</em>, <em>estimated_intervals_hier</em>, <em>transitive=False</em>, <em>window=15.0</em>, <em>frame_size=0.1</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.hierarchy.tmeasure" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the tree measures for hierarchical segment annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals_hier</strong> : list of ndarray</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">reference_intervals_hier[i]</span></code> contains the segment intervals
(in seconds) for the <code class="docutils literal"><span class="pre">i</span></code> th layer of the annotations.  Layers are
ordered from top to bottom, so that the last list of intervals should
be the most specific.</p>
</div></blockquote>
<p><strong>estimated_intervals_hier</strong> : list of ndarray</p>
<blockquote>
<div><p>Like <code class="docutils literal"><span class="pre">reference_intervals_hier</span></code> but for the estimated annotation</p>
</div></blockquote>
<p><strong>transitive</strong> : bool</p>
<blockquote>
<div><p>whether to compute the t-measures using transitivity or not.</p>
</div></blockquote>
<p><strong>window</strong> : float &gt; 0</p>
<blockquote>
<div><p>size of the window (in seconds).  For each query frame q,
result frames are only counted within q +- window.</p>
</div></blockquote>
<p><strong>frame_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>length (in seconds) of frames.  The frame size cannot be longer than
the window.</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>beta parameter for the F-measure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>t_precision</strong> : number [0, 1]</p>
<blockquote>
<div><p>T-measure Precision</p>
</div></blockquote>
<p><strong>t_recall</strong> : number [0, 1]</p>
<blockquote>
<div><p>T-measure Recall</p>
</div></blockquote>
<p><strong>t_measure</strong> : number [0, 1]</p>
<blockquote>
<div><p>F-beta measure for <code class="docutils literal"><span class="pre">(t_precision,</span> <span class="pre">t_recall)</span></code></p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>If either of the input hierarchies are inconsistent</p>
<p>If the input hierarchies have different time durations</p>
<p>If <code class="docutils literal"><span class="pre">frame_size</span> <span class="pre">&gt;</span> <span class="pre">window</span></code> or <code class="docutils literal"><span class="pre">frame_size</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.hierarchy.lmeasure">
<code class="descclassname">mir_eval.hierarchy.</code><code class="descname">lmeasure</code><span class="sig-paren">(</span><em>reference_intervals_hier</em>, <em>reference_labels_hier</em>, <em>estimated_intervals_hier</em>, <em>estimated_labels_hier</em>, <em>frame_size=0.1</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.hierarchy.lmeasure" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the tree measures for hierarchical segment annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals_hier</strong> : list of ndarray</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">reference_intervals_hier[i]</span></code> contains the segment intervals
(in seconds) for the <code class="docutils literal"><span class="pre">i</span></code> th layer of the annotations.  Layers are
ordered from top to bottom, so that the last list of intervals should
be the most specific.</p>
</div></blockquote>
<p><strong>reference_labels_hier</strong> : list of list of str</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">reference_labels_hier[i]</span></code> contains the segment labels for the
<a href="#id30"><span class="problematic" id="id31">``</span></a>i``th layer of the annotations</p>
</div></blockquote>
<p><strong>estimated_intervals_hier</strong> : list of ndarray</p>
<p><strong>estimated_labels_hier</strong> : list of ndarray</p>
<blockquote>
<div><p>Like <code class="docutils literal"><span class="pre">reference_intervals_hier</span></code> and <code class="docutils literal"><span class="pre">reference_labels_hier</span></code>
but for the estimated annotation</p>
</div></blockquote>
<p><strong>frame_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>length (in seconds) of frames.  The frame size cannot be longer than
the window.</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>beta parameter for the F-measure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>l_precision</strong> : number [0, 1]</p>
<blockquote>
<div><p>L-measure Precision</p>
</div></blockquote>
<p><strong>l_recall</strong> : number [0, 1]</p>
<blockquote>
<div><p>L-measure Recall</p>
</div></blockquote>
<p><strong>l_measure</strong> : number [0, 1]</p>
<blockquote>
<div><p>F-beta measure for <code class="docutils literal"><span class="pre">(l_precision,</span> <span class="pre">l_recall)</span></code></p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>If either of the input hierarchies are inconsistent</p>
<p>If the input hierarchies have different time durations</p>
<p>If <code class="docutils literal"><span class="pre">frame_size</span> <span class="pre">&gt;</span> <span class="pre">window</span></code> or <code class="docutils literal"><span class="pre">frame_size</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.hierarchy.evaluate">
<code class="descclassname">mir_eval.hierarchy.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>ref_intervals_hier</em>, <em>ref_labels_hier</em>, <em>est_intervals_hier</em>, <em>est_labels_hier</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.hierarchy.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all hierarchical structure metrics for the given reference and
estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals_hier</strong> : list of list-like</p>
<p><strong>ref_labels_hier</strong> : list of list of str</p>
<p><strong>est_intervals_hier</strong> : list of list-like</p>
<p><strong>est_labels_hier</strong> : list of list of str</p>
<blockquote>
<div><p>Hierarchical annotations are encoded as an ordered list
of segmentations.  Each segmentation itself is a list (or list-like)
of intervals (*_intervals_hier) and a list of lists of labels
(*_labels_hier).</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>additional keyword arguments to the evaluation metrics.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> :  OrderedDict</p>
<blockquote>
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
<p>T-measures are computed in both the “full” (<code class="docutils literal"><span class="pre">transitive=True</span></code>) and
“reduced” (<code class="docutils literal"><span class="pre">transitive=False</span></code>) modes.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>Thrown when the provided annotations are not valid.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>A toy example with two two-layer annotations</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_i</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">60</span><span class="p">]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_i</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">60</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">60</span><span class="p">]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref_l</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_l</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">hierarchy</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_i</span><span class="p">,</span> <span class="n">ref_l</span><span class="p">,</span> <span class="n">est_i</span><span class="p">,</span> <span class="n">est_l</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
<span class="go">{&#39;T-Measure full&#39;: 0.94822745804853459,</span>
<span class="go"> &#39;T-Measure reduced&#39;: 0.8732458222764804,</span>
<span class="go"> &#39;T-Precision full&#39;: 0.96569179094693058,</span>
<span class="go"> &#39;T-Precision reduced&#39;: 0.89939075137018787,</span>
<span class="go"> &#39;T-Recall full&#39;: 0.93138358189386117,</span>
<span class="go"> &#39;T-Recall reduced&#39;: 0.84857799953694923}</span>
</pre></div>
</div>
<p>A more realistic example, using SALAMI pre-parsed annotations</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">load_salami</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="gp">... </span>    <span class="s2">&quot;load SALAMI event format as labeled intervals&quot;</span>
<span class="gp">... </span>    <span class="n">events</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_events</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">intervals</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">boundaries_to_intervals</span><span class="p">(</span><span class="n">events</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">labels</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref_files</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;data/10/parsed/textfile1_uppercase.txt&#39;</span><span class="p">,</span>
<span class="gp">... </span>             <span class="s1">&#39;data/10/parsed/textfile1_lowercase.txt&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_files</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;data/10/parsed/textfile2_uppercase.txt&#39;</span><span class="p">,</span>
<span class="gp">... </span>             <span class="s1">&#39;data/10/parsed/textfile2_lowercase.txt&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref</span> <span class="o">=</span> <span class="p">[</span><span class="n">load_salami</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">ref_files</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref_int</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">ref</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref_lab</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">ref</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span> <span class="o">=</span> <span class="p">[</span><span class="n">load_salami</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">est_files</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_int</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">est</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_lab</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">est</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">hierarchy</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_int</span><span class="p">,</span> <span class="n">ref_lab</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">est_hier</span><span class="p">,</span> <span class="n">est_lab</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
<span class="go">{&#39;T-Measure full&#39;: 0.66029225561405358,</span>
<span class="go"> &#39;T-Measure reduced&#39;: 0.62001868041578034,</span>
<span class="go"> &#39;T-Precision full&#39;: 0.66844764668949885,</span>
<span class="go"> &#39;T-Precision reduced&#39;: 0.63252297209957919,</span>
<span class="go"> &#39;T-Recall full&#39;: 0.6523334654992341,</span>
<span class="go"> &#39;T-Recall reduced&#39;: 0.60799919710921635}</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.separation">
<span id="mir-eval-separation"></span><h3><a class="reference internal" href="#module-mir_eval.separation" title="mir_eval.separation"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.separation</span></code></a><a class="headerlink" href="#module-mir_eval.separation" title="Permalink to this headline">¶</a></h3>
<p>Source separation algorithms attempt to extract recordings of individual
sources from a recording of a mixture of sources.  Evaluation methods for
source separation compare the extracted sources from reference sources and
attempt to measure the perceptual quality of the separation.</p>
<dl class="docutils">
<dt>See also the bss_eval MATLAB toolbox:</dt>
<dd><a class="reference external" href="http://bass-db.gforge.inria.fr/bss_eval/">http://bass-db.gforge.inria.fr/bss_eval/</a></dd>
</dl>
<div class="section" id="id32">
<h4>Conventions<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h4>
<p>An audio signal is expected to be in the format of a 1-dimensional array where
the entries are the samples of the audio signal.  When providing a group of
estimated or reference sources, they should be provided in a 2-dimensional
array, where the first dimension corresponds to the source number and the
second corresponds to the samples.</p>
</div>
<div class="section" id="id33">
<h4>Metrics<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.separation.bss_eval_sources" title="mir_eval.separation.bss_eval_sources"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.separation.bss_eval_sources()</span></code></a>: Computes the bss_eval_sources
metrics from bss_eval, which optionally optimally match the estimated sources
to the reference sources and measure the distortion and artifacts present in
the estimated sources as well as the interference between them.</li>
<li><a class="reference internal" href="#mir_eval.separation.bss_eval_sources_framewise" title="mir_eval.separation.bss_eval_sources_framewise"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.separation.bss_eval_sources_framewise()</span></code></a>: Computes the
bss_eval_sources metrics on a frame-by-frame basis.</li>
<li><a class="reference internal" href="#mir_eval.separation.bss_eval_images" title="mir_eval.separation.bss_eval_images"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.separation.bss_eval_images()</span></code></a>: Computes the bss_eval_images
metrics from bss_eval, which includes the metrics in
<a class="reference internal" href="#mir_eval.separation.bss_eval_sources" title="mir_eval.separation.bss_eval_sources"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.separation.bss_eval_sources()</span></code></a> plus the image to spatial
distortion ratio.</li>
<li><a class="reference internal" href="#mir_eval.separation.bss_eval_images_framewise" title="mir_eval.separation.bss_eval_images_framewise"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.separation.bss_eval_images_framewise()</span></code></a>: Computes the
bss_eval_images metrics on a frame-by-frame basis.</li>
</ul>
</div>
<div class="section" id="id34">
<h4>References<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><table class="docutils footnote" frame="void" id="vincent2006performance" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[12]</td><td><em>(<a class="fn-backref" href="#id35">1</a>, <a class="fn-backref" href="#id37">2</a>)</em> Emmanuel Vincent, Rémi Gribonval, and Cédric
Févotte, “Performance measurement in blind audio source separation,” IEEE
Trans. on Audio, Speech and Language Processing, 14(4):1462-1469, 2006.</td></tr>
</tbody>
</table>
</div></blockquote>
<dl class="function">
<dt id="mir_eval.separation.validate">
<code class="descclassname">mir_eval.separation.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>reference_sources</em>, <em>estimated_sources</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input data to a metric are valid, and throws helpful
errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_sources</strong> : np.ndarray, shape=(nsrc, nsampl)</p>
<blockquote>
<div><p>matrix containing true sources</p>
</div></blockquote>
<p><strong>estimated_sources</strong> : np.ndarray, shape=(nsrc, nsampl)</p>
<blockquote class="last">
<div><p>matrix containing estimated sources</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.separation.bss_eval_sources">
<code class="descclassname">mir_eval.separation.</code><code class="descname">bss_eval_sources</code><span class="sig-paren">(</span><em>reference_sources</em>, <em>estimated_sources</em>, <em>compute_permutation=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.bss_eval_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordering and measurement of the separation quality for estimated source
signals in terms of filtered true source, interference and artifacts.</p>
<p>The decomposition allows a time-invariant filter distortion of length
512, as described in Section III.B of <a class="footnote-reference" href="#vincent2006performance" id="id35">[12]</a>.</p>
<p>Passing <code class="docutils literal"><span class="pre">False</span></code> for <code class="docutils literal"><span class="pre">compute_permutation</span></code> will improve the computation
performance of the evaluation; however, it is not always appropriate and
is not the way that the BSS_EVAL Matlab toolbox computes bss_eval_sources.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_sources</strong> : np.ndarray, shape=(nsrc, nsampl)</p>
<blockquote>
<div><p>matrix containing true sources (must have same shape as
estimated_sources)</p>
</div></blockquote>
<p><strong>estimated_sources</strong> : np.ndarray, shape=(nsrc, nsampl)</p>
<blockquote>
<div><p>matrix containing estimated sources (must have same shape as
reference_sources)</p>
</div></blockquote>
<p><strong>compute_permutation</strong> : bool, optional</p>
<blockquote>
<div><p>compute permutation of estimate/source combinations (True by default)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sdr</strong> : np.ndarray, shape=(nsrc,)</p>
<blockquote>
<div><p>vector of Signal to Distortion Ratios (SDR)</p>
</div></blockquote>
<p><strong>sir</strong> : np.ndarray, shape=(nsrc,)</p>
<blockquote>
<div><p>vector of Source to Interference Ratios (SIR)</p>
</div></blockquote>
<p><strong>sar</strong> : np.ndarray, shape=(nsrc,)</p>
<blockquote>
<div><p>vector of Sources to Artifacts Ratios (SAR)</p>
</div></blockquote>
<p><strong>perm</strong> : np.ndarray, shape=(nsrc,)</p>
<blockquote class="last">
<div><p>vector containing the best ordering of estimated sources in
the mean SIR sense (estimated source number <code class="docutils literal"><span class="pre">perm[j]</span></code> corresponds to
true source number <code class="docutils literal"><span class="pre">j</span></code>). Note: <code class="docutils literal"><span class="pre">perm</span></code> will be <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">...,</span>
<span class="pre">nsrc-1]</span></code> if <code class="docutils literal"><span class="pre">compute_permutation</span></code> is <code class="docutils literal"><span class="pre">False</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[13]</td><td>Emmanuel Vincent, Shoko Araki, Fabian J. Theis, Guido Nolte, Pau
Bofill, Hiroshi Sawada, Alexey Ozerov, B. Vikrham Gowreesunker, Dominik
Lutter and Ngoc Q.K. Duong, “The Signal Separation Evaluation Campaign
(2007-2010): Achievements and remaining challenges”, Signal Processing,
92, pp. 1928-1936, 2012.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># reference_sources[n] should be an ndarray of samples of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n&#39;th reference source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimated_sources[n] should be the same for the n&#39;th estimated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sdr</span><span class="p">,</span> <span class="n">sir</span><span class="p">,</span> <span class="n">sar</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">perm</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">separation</span><span class="o">.</span><span class="n">bss_eval_sources</span><span class="p">(</span><span class="n">reference_sources</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">estimated_sources</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.separation.bss_eval_sources_framewise">
<code class="descclassname">mir_eval.separation.</code><code class="descname">bss_eval_sources_framewise</code><span class="sig-paren">(</span><em>reference_sources</em>, <em>estimated_sources</em>, <em>window=1323000</em>, <em>hop=661500</em>, <em>compute_permutation=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.bss_eval_sources_framewise" title="Permalink to this definition">¶</a></dt>
<dd><p>Framewise computation of bss_eval_sources</p>
<p>Please be aware that this function does not compute permutations (by
default) on the possible relations between reference_sources and
estimated_sources due to the dangers of a changing permutation. Therefore
(by default), it assumes that <code class="docutils literal"><span class="pre">reference_sources[i]</span></code> corresponds to
<code class="docutils literal"><span class="pre">estimated_sources[i]</span></code>. To enable computing permutations please set
<code class="docutils literal"><span class="pre">compute_permutation</span></code> to be <code class="docutils literal"><span class="pre">True</span></code> and check that the returned <code class="docutils literal"><span class="pre">perm</span></code>
is identical for all windows.</p>
<p>NOTE: if <code class="docutils literal"><span class="pre">reference_sources</span></code> and <code class="docutils literal"><span class="pre">estimated_sources</span></code> would be evaluated
using only a single window or are shorter than the window length, the
result of <a class="reference internal" href="#mir_eval.separation.bss_eval_sources" title="mir_eval.separation.bss_eval_sources"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.separation.bss_eval_sources()</span></code></a> called on
<code class="docutils literal"><span class="pre">reference_sources</span></code> and <code class="docutils literal"><span class="pre">estimated_sources</span></code> (with the
<code class="docutils literal"><span class="pre">compute_permutation</span></code> parameter passed to
<a class="reference internal" href="#mir_eval.separation.bss_eval_sources" title="mir_eval.separation.bss_eval_sources"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.separation.bss_eval_sources()</span></code></a>) is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_sources</strong> : np.ndarray, shape=(nsrc, nsampl)</p>
<blockquote>
<div><p>matrix containing true sources (must have the same shape as
<code class="docutils literal"><span class="pre">estimated_sources</span></code>)</p>
</div></blockquote>
<p><strong>estimated_sources</strong> : np.ndarray, shape=(nsrc, nsampl)</p>
<blockquote>
<div><p>matrix containing estimated sources (must have the same shape as
<code class="docutils literal"><span class="pre">reference_sources</span></code>)</p>
</div></blockquote>
<p><strong>window</strong> : int, optional</p>
<blockquote>
<div><p>Window length for framewise evaluation (default value is 30s at a
sample rate of 44.1kHz)</p>
</div></blockquote>
<p><strong>hop</strong> : int, optional</p>
<blockquote>
<div><p>Hop size for framewise evaluation (default value is 15s at a
sample rate of 44.1kHz)</p>
</div></blockquote>
<p><strong>compute_permutation</strong> : bool, optional</p>
<blockquote>
<div><p>compute permutation of estimate/source combinations for all windows
(False by default)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sdr</strong> : np.ndarray, shape=(nsrc, nframes)</p>
<blockquote>
<div><p>vector of Signal to Distortion Ratios (SDR)</p>
</div></blockquote>
<p><strong>sir</strong> : np.ndarray, shape=(nsrc, nframes)</p>
<blockquote>
<div><p>vector of Source to Interference Ratios (SIR)</p>
</div></blockquote>
<p><strong>sar</strong> : np.ndarray, shape=(nsrc, nframes)</p>
<blockquote>
<div><p>vector of Sources to Artifacts Ratios (SAR)</p>
</div></blockquote>
<p><strong>perm</strong> : np.ndarray, shape=(nsrc, nframes)</p>
<blockquote class="last">
<div><p>vector containing the best ordering of estimated sources in
the mean SIR sense (estimated source number <code class="docutils literal"><span class="pre">perm[j]</span></code> corresponds to
true source number <code class="docutils literal"><span class="pre">j</span></code>).  Note: <code class="docutils literal"><span class="pre">perm</span></code> will be <code class="docutils literal"><span class="pre">range(nsrc)</span></code> for
all windows if <code class="docutils literal"><span class="pre">compute_permutation</span></code> is <code class="docutils literal"><span class="pre">False</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># reference_sources[n] should be an ndarray of samples of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n&#39;th reference source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimated_sources[n] should be the same for the n&#39;th estimated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sdr</span><span class="p">,</span> <span class="n">sir</span><span class="p">,</span> <span class="n">sar</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">perm</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">separation</span><span class="o">.</span><span class="n">bss_eval_sources_framewise</span><span class="p">(</span>
<span class="go">         reference_sources,</span>
<span class="gp">... </span>     <span class="n">estimated_sources</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.separation.bss_eval_images">
<code class="descclassname">mir_eval.separation.</code><code class="descname">bss_eval_images</code><span class="sig-paren">(</span><em>reference_sources</em>, <em>estimated_sources</em>, <em>compute_permutation=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.bss_eval_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of the bss_eval_images function from the
BSS_EVAL Matlab toolbox.</p>
<p>Ordering and measurement of the separation quality for estimated source
signals in terms of filtered true source, interference and artifacts.
This method also provides the ISR measure.</p>
<p>The decomposition allows a time-invariant filter distortion of length
512, as described in Section III.B of <a class="footnote-reference" href="#vincent2006performance" id="id37">[12]</a>.</p>
<p>Passing <code class="docutils literal"><span class="pre">False</span></code> for <code class="docutils literal"><span class="pre">compute_permutation</span></code> will improve the computation
performance of the evaluation; however, it is not always appropriate and
is not the way that the BSS_EVAL Matlab toolbox computes bss_eval_images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_sources</strong> : np.ndarray, shape=(nsrc, nsampl, nchan)</p>
<blockquote>
<div><p>matrix containing true sources</p>
</div></blockquote>
<p><strong>estimated_sources</strong> : np.ndarray, shape=(nsrc, nsampl, nchan)</p>
<blockquote>
<div><p>matrix containing estimated sources</p>
</div></blockquote>
<p><strong>compute_permutation</strong> : bool, optional</p>
<blockquote>
<div><p>compute permutation of estimate/source combinations (True by default)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sdr</strong> : np.ndarray, shape=(nsrc,)</p>
<blockquote>
<div><p>vector of Signal to Distortion Ratios (SDR)</p>
</div></blockquote>
<p><strong>isr</strong> : np.ndarray, shape=(nsrc,)</p>
<blockquote>
<div><p>vector of source Image to Spatial distortion Ratios (ISR)</p>
</div></blockquote>
<p><strong>sir</strong> : np.ndarray, shape=(nsrc,)</p>
<blockquote>
<div><p>vector of Source to Interference Ratios (SIR)</p>
</div></blockquote>
<p><strong>sar</strong> : np.ndarray, shape=(nsrc,)</p>
<blockquote>
<div><p>vector of Sources to Artifacts Ratios (SAR)</p>
</div></blockquote>
<p><strong>perm</strong> : np.ndarray, shape=(nsrc,)</p>
<blockquote class="last">
<div><p>vector containing the best ordering of estimated sources in
the mean SIR sense (estimated source number <code class="docutils literal"><span class="pre">perm[j]</span></code> corresponds to
true source number <code class="docutils literal"><span class="pre">j</span></code>).  Note: <code class="docutils literal"><span class="pre">perm</span></code> will be <code class="docutils literal"><span class="pre">(1,2,...,nsrc)</span></code>
if <code class="docutils literal"><span class="pre">compute_permutation</span></code> is <code class="docutils literal"><span class="pre">False</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id38" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[14]</td><td>Emmanuel Vincent, Shoko Araki, Fabian J. Theis, Guido Nolte, Pau
Bofill, Hiroshi Sawada, Alexey Ozerov, B. Vikrham Gowreesunker, Dominik
Lutter and Ngoc Q.K. Duong, “The Signal Separation Evaluation Campaign
(2007-2010): Achievements and remaining challenges”, Signal Processing,
92, pp. 1928-1936, 2012.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># reference_sources[n] should be an ndarray of samples of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n&#39;th reference source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimated_sources[n] should be the same for the n&#39;th estimated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sdr</span><span class="p">,</span> <span class="n">isr</span><span class="p">,</span> <span class="n">sir</span><span class="p">,</span> <span class="n">sar</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">perm</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">separation</span><span class="o">.</span><span class="n">bss_eval_images</span><span class="p">(</span><span class="n">reference_sources</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">estimated_sources</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.separation.bss_eval_images_framewise">
<code class="descclassname">mir_eval.separation.</code><code class="descname">bss_eval_images_framewise</code><span class="sig-paren">(</span><em>reference_sources</em>, <em>estimated_sources</em>, <em>window=1323000</em>, <em>hop=661500</em>, <em>compute_permutation=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.bss_eval_images_framewise" title="Permalink to this definition">¶</a></dt>
<dd><p>Framewise computation of bss_eval_images</p>
<p>Please be aware that this function does not compute permutations (by
default) on the possible relations between <code class="docutils literal"><span class="pre">reference_sources</span></code> and
<code class="docutils literal"><span class="pre">estimated_sources</span></code> due to the dangers of a changing permutation.
Therefore (by default), it assumes that <code class="docutils literal"><span class="pre">reference_sources[i]</span></code>
corresponds to <code class="docutils literal"><span class="pre">estimated_sources[i]</span></code>. To enable computing permutations
please set <code class="docutils literal"><span class="pre">compute_permutation</span></code> to be <code class="docutils literal"><span class="pre">True</span></code> and check that the
returned <code class="docutils literal"><span class="pre">perm</span></code> is identical for all windows.</p>
<p>NOTE: if <code class="docutils literal"><span class="pre">reference_sources</span></code> and <code class="docutils literal"><span class="pre">estimated_sources</span></code> would be evaluated
using only a single window or are shorter than the window length, the
result of <code class="docutils literal"><span class="pre">bss_eval_images</span></code> called on <code class="docutils literal"><span class="pre">reference_sources</span></code> and
<code class="docutils literal"><span class="pre">estimated_sources</span></code> (with the <code class="docutils literal"><span class="pre">compute_permutation</span></code> parameter passed to
<code class="docutils literal"><span class="pre">bss_eval_images</span></code>) is returned</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_sources</strong> : np.ndarray, shape=(nsrc, nsampl, nchan)</p>
<blockquote>
<div><p>matrix containing true sources (must have the same shape as
<code class="docutils literal"><span class="pre">estimated_sources</span></code>)</p>
</div></blockquote>
<p><strong>estimated_sources</strong> : np.ndarray, shape=(nsrc, nsampl, nchan)</p>
<blockquote>
<div><p>matrix containing estimated sources (must have the same shape as
<code class="docutils literal"><span class="pre">reference_sources</span></code>)</p>
</div></blockquote>
<p><strong>window</strong> : int</p>
<blockquote>
<div><p>Window length for framewise evaluation</p>
</div></blockquote>
<p><strong>hop</strong> : int</p>
<blockquote>
<div><p>Hop size for framewise evaluation</p>
</div></blockquote>
<p><strong>compute_permutation</strong> : bool, optional</p>
<blockquote>
<div><p>compute permutation of estimate/source combinations for all windows
(False by default)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sdr</strong> : np.ndarray, shape=(nsrc, nframes)</p>
<blockquote>
<div><p>vector of Signal to Distortion Ratios (SDR)</p>
</div></blockquote>
<p><strong>isr</strong> : np.ndarray, shape=(nsrc, nframes)</p>
<blockquote>
<div><p>vector of source Image to Spatial distortion Ratios (ISR)</p>
</div></blockquote>
<p><strong>sir</strong> : np.ndarray, shape=(nsrc, nframes)</p>
<blockquote>
<div><p>vector of Source to Interference Ratios (SIR)</p>
</div></blockquote>
<p><strong>sar</strong> : np.ndarray, shape=(nsrc, nframes)</p>
<blockquote>
<div><p>vector of Sources to Artifacts Ratios (SAR)</p>
</div></blockquote>
<p><strong>perm</strong> : np.ndarray, shape=(nsrc, nframes)</p>
<blockquote class="last">
<div><p>vector containing the best ordering of estimated sources in
the mean SIR sense (estimated source number perm[j] corresponds to
true source number j)
Note: perm will be range(nsrc) for all windows if compute_permutation
is False</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># reference_sources[n] should be an ndarray of samples of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n&#39;th reference source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimated_sources[n] should be the same for the n&#39;th estimated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sdr</span><span class="p">,</span> <span class="n">isr</span><span class="p">,</span> <span class="n">sir</span><span class="p">,</span> <span class="n">sar</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">perm</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">separation</span><span class="o">.</span><span class="n">bss_eval_images_framewise</span><span class="p">(</span>
<span class="go">         reference_sources,</span>
<span class="gp">... </span>     <span class="n">estimated_sources</span><span class="p">,</span>
<span class="go">         window,</span>
<span class="go">....     hop)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.separation.evaluate">
<code class="descclassname">mir_eval.separation.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>reference_sources</em>, <em>estimated_sources</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated signals.</p>
<p>NOTE: This will always compute <a class="reference internal" href="#mir_eval.separation.bss_eval_images" title="mir_eval.separation.bss_eval_images"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.separation.bss_eval_images()</span></code></a>
for any valid input and will additionally compute
<a class="reference internal" href="#mir_eval.separation.bss_eval_sources" title="mir_eval.separation.bss_eval_sources"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.separation.bss_eval_sources()</span></code></a> for valid input with fewer
than 3 dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_sources</strong> : np.ndarray, shape=(nsrc, nsampl[, nchan])</p>
<blockquote>
<div><p>matrix containing true sources</p>
</div></blockquote>
<p><strong>estimated_sources</strong> : np.ndarray, shape=(nsrc, nsampl[, nchan])</p>
<blockquote>
<div><p>matrix containing estimated sources</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># reference_sources[n] should be an ndarray of samples of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n&#39;th reference source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimated_sources[n] should be the same for the n&#39;th estimated source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">separation</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_sources</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">estimated_sources</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.tempo">
<span id="mir-eval-tempo"></span><h3><a class="reference internal" href="#module-mir_eval.tempo" title="mir_eval.tempo"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.tempo</span></code></a><a class="headerlink" href="#module-mir_eval.tempo" title="Permalink to this headline">¶</a></h3>
<p>The goal of a tempo estimation algorithm is to automatically detect the tempo
of a piece of music, measured in beats per minute (BPM).</p>
<p>See <a class="reference external" href="http://www.music-ir.org/mirex/wiki/2014:Audio_Tempo_Estimation">http://www.music-ir.org/mirex/wiki/2014:Audio_Tempo_Estimation</a> for a
description of the task and evaluation criteria.</p>
<div class="section" id="id39">
<h4>Conventions<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h4>
<p>Reference tempi should be strictly positive, and provided in ascending order
as a numpy array of length 2.  Estimated tempi are allowed to be 0, but
otherwise are subject to the same constraints as reference.</p>
<p>The weighting value from the reference must be a float in the range [0, 1].</p>
</div>
<div class="section" id="id40">
<h4>Metrics<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.tempo.detection" title="mir_eval.tempo.detection"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.tempo.detection()</span></code></a>: Relative error, hits, and weighted
precision of tempo estimation.</li>
</ul>
<dl class="function">
<dt id="mir_eval.tempo.validate_tempi">
<code class="descclassname">mir_eval.tempo.</code><code class="descname">validate_tempi</code><span class="sig-paren">(</span><em>tempi</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.tempo.validate_tempi" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that there are two non-negative tempi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tempi</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>length-2 array of tempo, in bpm</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.tempo.validate">
<code class="descclassname">mir_eval.tempo.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>reference_tempi</em>, <em>reference_weight</em>, <em>estimated_tempi</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.tempo.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid tempo
annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_tempi</strong> : np.ndarray</p>
<blockquote>
<div><p>reference tempo values, in bpm</p>
</div></blockquote>
<p><strong>reference_weight</strong> : float</p>
<blockquote>
<div><p>perceptual weight of slow vs fast in reference</p>
</div></blockquote>
<p><strong>estimated_tempi</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>estimated tempo values, in bpm</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.tempo.detection">
<code class="descclassname">mir_eval.tempo.</code><code class="descname">detection</code><span class="sig-paren">(</span><em>reference_tempi</em>, <em>reference_weight</em>, <em>estimated_tempi</em>, <em>tol=0.08</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.tempo.detection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the tempo detection accuracy metric.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_tempi</strong> : np.ndarray, shape=(2,)</p>
<blockquote>
<div><p>Two non-negative reference tempi</p>
</div></blockquote>
<p><strong>reference_weight</strong> : float &gt; 0</p>
<blockquote>
<div><p>The relative strength of <code class="docutils literal"><span class="pre">reference_tempi[0]</span></code> vs
<code class="docutils literal"><span class="pre">reference_tempi[1]</span></code>.</p>
</div></blockquote>
<p><strong>estimated_tempi</strong> : np.ndarray, shape=(2,)</p>
<blockquote>
<div><p>Two non-negative estimated tempi.</p>
</div></blockquote>
<p><strong>tol</strong> : float in [0, 1]:</p>
<blockquote>
<div><p>The maximum allowable deviation from a reference tempo to
count as a hit.
<code class="docutils literal"><span class="pre">|est_t</span> <span class="pre">-</span> <span class="pre">ref_t|</span> <span class="pre">&lt;=</span> <span class="pre">tol</span> <span class="pre">*</span> <span class="pre">ref_t</span></code>
(Default value = 0.08)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p_score</strong> : float in [0, 1]</p>
<blockquote>
<div><p>Weighted average of recalls:
<code class="docutils literal"><span class="pre">reference_weight</span> <span class="pre">*</span> <span class="pre">hits[0]</span> <span class="pre">+</span> <span class="pre">(1</span> <span class="pre">-</span> <span class="pre">reference_weight)</span> <span class="pre">*</span> <span class="pre">hits[1]</span></code></p>
</div></blockquote>
<p><strong>one_correct</strong> : bool</p>
<blockquote>
<div><p>True if at least one reference tempo was correctly estimated</p>
</div></blockquote>
<p><strong>both_correct</strong> : bool</p>
<blockquote>
<div><p>True if both reference tempi were correctly estimated</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>If the input tempi are ill-formed</p>
<p>If the reference weight is not in the range [0, 1]</p>
<p>If <code class="docutils literal"><span class="pre">tol</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code> or <code class="docutils literal"><span class="pre">tol</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.tempo.evaluate">
<code class="descclassname">mir_eval.tempo.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>reference_tempi</em>, <em>reference_weight</em>, <em>estimated_tempi</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.tempo.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_tempi</strong> : np.ndarray, shape=(2,)</p>
<blockquote>
<div><p>Two non-negative reference tempi</p>
</div></blockquote>
<p><strong>reference_weight</strong> : float &gt; 0</p>
<blockquote>
<div><p>The relative strength of <code class="docutils literal"><span class="pre">reference_tempi[0]</span></code> vs
<code class="docutils literal"><span class="pre">reference_tempi[1]</span></code>.</p>
</div></blockquote>
<p><strong>estimated_tempi</strong> : np.ndarray, shape=(2,)</p>
<blockquote>
<div><p>Two non-negative estimated tempi.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.transcription">
<span id="mir-eval-transcription"></span><h3><a class="reference internal" href="#module-mir_eval.transcription" title="mir_eval.transcription"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.transcription</span></code></a><a class="headerlink" href="#module-mir_eval.transcription" title="Permalink to this headline">¶</a></h3>
<p>The aim of a transcription algorithm is to produce a symbolic representation of
a recorded piece of music in the form of a set of discrete notes. There are
different ways to represent notes symbolically. Here we use the piano-roll
convention, meaning each note has a start time, a duration (or end time), and
a single, constant, pitch value. Pitch values can be quantized (e.g. to a
semitone grid tuned to 440 Hz), but do not have to be. Also, the transcription
can contain the notes of a single instrument or voice (for example the melody),
or the notes of all instruments/voices in the recording. This module is
instrument agnostic: all notes in the estimate are compared against all notes
in the reference.</p>
<p>There are many metrics for evaluating transcription algorithms. Here we limit
ourselves to the most simple and commonly used: given two sets of notes, we
count how many estimated notes match the reference, and how many do not. Based
on these counts we compute the precision, recall, f-measure and overlap ratio
of the estimate given the reference. The default criteria for considering two
notes to be a match are adopted from the <a class="reference external" href="http://www.music-ir.org/mirex/wiki/2015:Multiple_Fundamental_Frequency_Estimation_%26_Tracking_Results_-_MIREX_Dataset#Task_2:Note_Tracking_.28NT.29">MIREX Multiple fundamental frequency
estimation and tracking, Note Tracking subtask (task 2)</a>:</p>
<p>“This subtask is evaluated in two different ways. In the first setup , a
returned note is assumed correct if its onset is within +-50ms of a reference
note and its F0 is within +- quarter tone of the corresponding reference note,
ignoring the returned offset values. In the second setup, on top of the above
requirements, a correct returned note is required to have an offset value
within 20% of the reference note’s duration around the reference note’s
offset, or within 50ms whichever is larger.”</p>
<p>In short, we compute precision, recall, f-measure and overlap ratio, once
without taking offsets into account, and the second time with.</p>
<p>For further details see Salamon, 2013 (page 186), and references therein:</p>
<blockquote>
<div>Salamon, J. (2013). Melody Extraction from Polyphonic Music Signals.
Ph.D. thesis, Universitat Pompeu Fabra, Barcelona, Spain, 2013.</div></blockquote>
<p>IMPORTANT NOTE: the evaluation code in <code class="docutils literal"><span class="pre">mir_eval</span></code> contains several important
differences with respect to the code used in MIREX 2015 for the Note Tracking
subtask on the Su dataset (henceforth “MIREX”):</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">mir_eval</span></code> uses bipartite graph matching to find the optimal pairing of
reference notes to estimated notes. MIREX uses a greedy matching algorithm,
which can produce sub-optimal note matching. This will result in
<code class="docutils literal"><span class="pre">mir_eval</span></code>’s metrics being slightly higher compared to MIREX.</li>
<li>MIREX rounds down the onset and offset times of each note to 2 decimal
points using <code class="docutils literal"><span class="pre">new_time</span> <span class="pre">=</span> <span class="pre">0.01</span> <span class="pre">*</span> <span class="pre">floor(time*100)</span></code>. <code class="docutils literal"><span class="pre">mir_eval</span></code> rounds down
the note onset and offset times to 4 decinal points. This will bring our
metrics down a notch compared to the MIREX results.</li>
<li>In the MIREX wiki, the criterion for matching offsets is that they must be
within <code class="docutils literal"><span class="pre">0.2</span> <span class="pre">*</span> <span class="pre">ref_duration</span></code> <strong>or 0.05 seconds from each other, whichever
is greater</strong> (i.e. <code class="docutils literal"><span class="pre">offset_dif</span> <span class="pre">&lt;=</span> <span class="pre">max(0.2</span> <span class="pre">*</span> <span class="pre">ref_duration,</span> <span class="pre">0.05)</span></code>. The
MIREX code however only uses a threshold of <code class="docutils literal"><span class="pre">0.2</span> <span class="pre">*</span> <span class="pre">ref_duration</span></code>, without
the 0.05 second minimum. Since <code class="docutils literal"><span class="pre">mir_eval</span></code> does include this minimum, it
might produce slightly higher results compared to MIREX.</li>
</ol>
<p>This means that differences 1 and 3 bring <code class="docutils literal"><span class="pre">mir_eval</span></code>’s metrics up compared to
MIREX, whilst 2 brings them down. Based on internal testing, overall the effect
of these three differences is that the Precision, Recall and F-measure returned
by <code class="docutils literal"><span class="pre">mir_eval</span></code> will be higher compared to MIREX by about 1%-2%.</p>
<p>Finally, note that different evaluation scripts have been used for the Multi-F0
Note Tracking task in MIREX over the years. In particular, some scripts used
<code class="docutils literal"><span class="pre">&lt;</span></code> for matching onsets, offsets, and pitch values, whilst the others used
<code class="docutils literal"><span class="pre">&lt;=</span></code> for these checks. <code class="docutils literal"><span class="pre">mir_eval</span></code> provides both options: by default the
latter (<code class="docutils literal"><span class="pre">&lt;=</span></code>) is used, but you can set <code class="docutils literal"><span class="pre">strict=True</span></code> when calling
<a class="reference internal" href="#mir_eval.transcription.precision_recall_f1_overlap" title="mir_eval.transcription.precision_recall_f1_overlap"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.transcription.precision_recall_f1_overlap()</span></code></a> in which case
<code class="docutils literal"><span class="pre">&lt;</span></code> will be used. The default value (<code class="docutils literal"><span class="pre">strict=False</span></code>) is the same as that
used in MIREX 2015 for the Note Tracking subtask on the Su dataset.</p>
<div class="section" id="id41">
<h4>Conventions<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h4>
<p>Notes should be provided in the form of an interval array and a pitch array.
The interval array contains two columns, one for note onsets and the second
for note offsets (each row represents a single note). The pitch array contains
one column with the corresponding note pitch values (one value per note),
represented by their fundamental frequency (f0) in Hertz.</p>
</div>
<div class="section" id="id42">
<h4>Metrics<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.transcription.precision_recall_f1_overlap" title="mir_eval.transcription.precision_recall_f1_overlap"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.transcription.precision_recall_f1_overlap()</span></code></a>: The precision,
recall, F-measure, and Average Overlap Ratio of the note transcription,
where an estimated note is considered correct if its pitch, onset and
(optionally) offset are sufficiently close to a reference note.</li>
<li><a class="reference internal" href="#mir_eval.transcription.onset_precision_recall_f1" title="mir_eval.transcription.onset_precision_recall_f1"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.transcription.onset_precision_recall_f1()</span></code></a>: The precision,
recall and F-measure of the note transcription, where an estimated note is
considered correct if its onset is sufficiently close to a reference note’s
onset. That is, these metrics are computed taking only note onsets into
account, meaning two notes could be matched even if they have very different
pitch values.</li>
<li><a class="reference internal" href="#mir_eval.transcription.offset_precision_recall_f1" title="mir_eval.transcription.offset_precision_recall_f1"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.transcription.offset_precision_recall_f1()</span></code></a>: The precision,
recall and F-measure of the note transcription, where an estimated note is
considered correct if its offset is sufficiently close to a reference note’s
offset. That is, these metrics are computed taking only note offsets into
account, meaning two notes could be matched even if they have very different
pitch values.</li>
</ul>
<dl class="function">
<dt id="mir_eval.transcription.validate">
<code class="descclassname">mir_eval.transcription.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_pitches</em>, <em>est_intervals</em>, <em>est_pitches</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like time intervals
and a pitch list, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>ref_pitches</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of reference pitch values in Hertz</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_pitches</strong> : np.ndarray, shape=(m,)</p>
<blockquote class="last">
<div><p>Array of estimated pitch values in Hertz</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription.validate_intervals">
<code class="descclassname">mir_eval.transcription.</code><code class="descname">validate_intervals</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>est_intervals</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.validate_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like time intervals,
and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote class="last">
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription.match_note_offsets">
<code class="descclassname">mir_eval.transcription.</code><code class="descname">match_note_offsets</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>est_intervals</em>, <em>offset_ratio=0.2</em>, <em>offset_min_tolerance=0.05</em>, <em>strict=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.match_note_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a maximum matching between reference and estimated notes,
only taking note offsets into account.</p>
<p>Given two note sequences represented by <code class="docutils literal"><span class="pre">ref_intervals</span></code> and
<code class="docutils literal"><span class="pre">est_intervals</span></code> (see <a class="reference internal" href="#mir_eval.io.load_valued_intervals" title="mir_eval.io.load_valued_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_valued_intervals()</span></code></a>), we seek
the largest set of correspondences <code class="docutils literal"><span class="pre">(i,</span> <span class="pre">j)</span></code> such that the offset of
reference note <code class="docutils literal"><span class="pre">i</span></code> has to be within <code class="docutils literal"><span class="pre">offset_tolerance</span></code> of the offset of
estimated note <code class="docutils literal"><span class="pre">j</span></code>, where <code class="docutils literal"><span class="pre">offset_tolerance</span></code> is equal to
<code class="docutils literal"><span class="pre">offset_ratio</span></code> times the reference note’s duration, i.e.  <code class="docutils literal"><span class="pre">offset_ratio</span>
<span class="pre">*</span> <span class="pre">ref_duration[i]</span></code> where <code class="docutils literal"><span class="pre">ref_duration[i]</span> <span class="pre">=</span> <span class="pre">ref_intervals[i,</span> <span class="pre">1]</span> <span class="pre">-</span>
<span class="pre">ref_intervals[i,</span> <span class="pre">0]</span></code>. If the resulting <code class="docutils literal"><span class="pre">offset_tolerance</span></code> is less than
<code class="docutils literal"><span class="pre">offset_min_tolerance</span></code> (50 ms by default) then <code class="docutils literal"><span class="pre">offset_min_tolerance</span></code>
is used instead.</p>
<p>Every reference note is matched against at most one estimated note.</p>
<p>Note there are separate functions <a class="reference internal" href="#mir_eval.transcription.match_note_onsets" title="mir_eval.transcription.match_note_onsets"><code class="xref py py-func docutils literal"><span class="pre">match_note_onsets()</span></code></a> and
<a class="reference internal" href="#mir_eval.transcription.match_notes" title="mir_eval.transcription.match_notes"><code class="xref py py-func docutils literal"><span class="pre">match_notes()</span></code></a> for matching notes based on onsets only or based on
onset, offset, and pitch, respectively. This is because the rules for
matching note onsets and matching note offsets are different.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>offset_ratio</strong> : float &gt; 0</p>
<blockquote>
<div><p>The ratio of the reference note’s duration used to define the
<code class="docutils literal"><span class="pre">offset_tolerance</span></code>. Default is 0.2 (20%), meaning the
<code class="docutils literal"><span class="pre">offset_tolerance</span></code> will equal the <code class="docutils literal"><span class="pre">ref_duration</span> <span class="pre">*</span> <span class="pre">0.2</span></code>, or 0.05 (50
ms), whichever is greater.</p>
</div></blockquote>
<p><strong>offset_min_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The minimum tolerance for offset matching. See <code class="docutils literal"><span class="pre">offset_ratio</span></code>
description for an explanation of how the offset tolerance is
determined.</p>
</div></blockquote>
<p><strong>strict</strong> : bool</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">strict=False</span></code> (the default), threshold checks for offset
matching are performed using <code class="docutils literal"><span class="pre">&lt;=</span></code> (less than or equal). If
<code class="docutils literal"><span class="pre">strict=True</span></code>, the threshold checks are performed using <code class="docutils literal"><span class="pre">&lt;</span></code> (less
than).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>matching</strong> : list of tuples</p>
<blockquote class="last">
<div><p>A list of matched reference and estimated notes.
<code class="docutils literal"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> where reference note <code class="docutils literal"><span class="pre">i</span></code> matches estimated
note <code class="docutils literal"><span class="pre">j</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription.match_note_onsets">
<code class="descclassname">mir_eval.transcription.</code><code class="descname">match_note_onsets</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>est_intervals</em>, <em>onset_tolerance=0.05</em>, <em>strict=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.match_note_onsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a maximum matching between reference and estimated notes,
only taking note onsets into account.</p>
<p>Given two note sequences represented by <code class="docutils literal"><span class="pre">ref_intervals</span></code> and
<code class="docutils literal"><span class="pre">est_intervals</span></code> (see <a class="reference internal" href="#mir_eval.io.load_valued_intervals" title="mir_eval.io.load_valued_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_valued_intervals()</span></code></a>), we see
the largest set of correspondences <code class="docutils literal"><span class="pre">(i,j)</span></code> such that the onset of
reference note <code class="docutils literal"><span class="pre">i</span></code> is within <code class="docutils literal"><span class="pre">onset_tolerance</span></code> of the onset of
estimated note <code class="docutils literal"><span class="pre">j</span></code>.</p>
<p>Every reference note is matched against at most one estimated note.</p>
<p>Note there are separate functions <a class="reference internal" href="#mir_eval.transcription.match_note_offsets" title="mir_eval.transcription.match_note_offsets"><code class="xref py py-func docutils literal"><span class="pre">match_note_offsets()</span></code></a> and
<a class="reference internal" href="#mir_eval.transcription.match_notes" title="mir_eval.transcription.match_notes"><code class="xref py py-func docutils literal"><span class="pre">match_notes()</span></code></a> for matching notes based on offsets only or based on
onset, offset, and pitch, respectively. This is because the rules for
matching note onsets and matching note offsets are different.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>onset_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The tolerance for an estimated note’s onset deviating from the
reference note’s onset, in seconds. Default is 0.05 (50 ms).</p>
</div></blockquote>
<p><strong>strict</strong> : bool</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">strict=False</span></code> (the default), threshold checks for onset matching
are performed using <code class="docutils literal"><span class="pre">&lt;=</span></code> (less than or equal). If <code class="docutils literal"><span class="pre">strict=True</span></code>,
the threshold checks are performed using <code class="docutils literal"><span class="pre">&lt;</span></code> (less than).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>matching</strong> : list of tuples</p>
<blockquote class="last">
<div><p>A list of matched reference and estimated notes.
<code class="docutils literal"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> where reference note <code class="docutils literal"><span class="pre">i</span></code> matches estimated
note <code class="docutils literal"><span class="pre">j</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription.match_notes">
<code class="descclassname">mir_eval.transcription.</code><code class="descname">match_notes</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_pitches</em>, <em>est_intervals</em>, <em>est_pitches</em>, <em>onset_tolerance=0.05</em>, <em>pitch_tolerance=50.0</em>, <em>offset_ratio=0.2</em>, <em>offset_min_tolerance=0.05</em>, <em>strict=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.match_notes" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a maximum matching between reference and estimated notes,
subject to onset, pitch and (optionally) offset constraints.</p>
<p>Given two note sequences represented by <code class="docutils literal"><span class="pre">ref_intervals</span></code>, <code class="docutils literal"><span class="pre">ref_pitches</span></code>,
<code class="docutils literal"><span class="pre">est_intervals</span></code> and <code class="docutils literal"><span class="pre">est_pitches</span></code>
(see <a class="reference internal" href="#mir_eval.io.load_valued_intervals" title="mir_eval.io.load_valued_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_valued_intervals()</span></code></a>), we seek the largest set
of correspondences <code class="docutils literal"><span class="pre">(i,</span> <span class="pre">j)</span></code> such that:</p>
<ol class="arabic simple">
<li>The onset of reference note <code class="docutils literal"><span class="pre">i</span></code> is within <code class="docutils literal"><span class="pre">onset_tolerance</span></code> of the
onset of estimated note <code class="docutils literal"><span class="pre">j</span></code>.</li>
<li>The pitch of reference note <code class="docutils literal"><span class="pre">i</span></code> is within <code class="docutils literal"><span class="pre">pitch_tolerance</span></code> of the
pitch of estimated note <code class="docutils literal"><span class="pre">j</span></code>.</li>
<li>If <code class="docutils literal"><span class="pre">offset_ratio</span></code> is not <code class="docutils literal"><span class="pre">None</span></code>, the offset of reference note <code class="docutils literal"><span class="pre">i</span></code>
has to be within <code class="docutils literal"><span class="pre">offset_tolerance</span></code> of the offset of estimated note
<code class="docutils literal"><span class="pre">j</span></code>, where <code class="docutils literal"><span class="pre">offset_tolerance</span></code> is equal to <code class="docutils literal"><span class="pre">offset_ratio</span></code> times the
reference note’s duration, i.e. <code class="docutils literal"><span class="pre">offset_ratio</span> <span class="pre">*</span> <span class="pre">ref_duration[i]</span></code> where
<code class="docutils literal"><span class="pre">ref_duration[i]</span> <span class="pre">=</span> <span class="pre">ref_intervals[i,</span> <span class="pre">1]</span> <span class="pre">-</span> <span class="pre">ref_intervals[i,</span> <span class="pre">0]</span></code>.  If the
resulting <code class="docutils literal"><span class="pre">offset_tolerance</span></code> is less than 0.05 (50 ms), 0.05 is used
instead.</li>
<li>If <code class="docutils literal"><span class="pre">offset_ratio</span></code> is <code class="docutils literal"><span class="pre">None</span></code>, note offsets are ignored, and only
criteria 1 and 2 are taken into consideration.</li>
</ol>
<p>Every reference note is matched against at most one estimated note.</p>
<p>This is useful for computing precision/recall metrics for note
transcription.</p>
<p>Note there are separate functions <a class="reference internal" href="#mir_eval.transcription.match_note_onsets" title="mir_eval.transcription.match_note_onsets"><code class="xref py py-func docutils literal"><span class="pre">match_note_onsets()</span></code></a> and
<a class="reference internal" href="#mir_eval.transcription.match_note_offsets" title="mir_eval.transcription.match_note_offsets"><code class="xref py py-func docutils literal"><span class="pre">match_note_offsets()</span></code></a> for matching notes based on onsets only or based
on offsets only, respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>ref_pitches</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of reference pitch values in Hertz</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_pitches</strong> : np.ndarray, shape=(m,)</p>
<blockquote>
<div><p>Array of estimated pitch values in Hertz</p>
</div></blockquote>
<p><strong>onset_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The tolerance for an estimated note’s onset deviating from the
reference note’s onset, in seconds. Default is 0.05 (50 ms).</p>
</div></blockquote>
<p><strong>pitch_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The tolerance for an estimated note’s pitch deviating from the
reference note’s pitch, in cents. Default is 50.0 (50 cents).</p>
</div></blockquote>
<p><strong>offset_ratio</strong> : float &gt; 0 or None</p>
<blockquote>
<div><p>The ratio of the reference note’s duration used to define the
offset_tolerance. Default is 0.2 (20%), meaning the
<code class="docutils literal"><span class="pre">offset_tolerance</span></code> will equal the <code class="docutils literal"><span class="pre">ref_duration</span> <span class="pre">*</span> <span class="pre">0.2</span></code>, or 0.05 (50
ms), whichever is greater. If <code class="docutils literal"><span class="pre">offset_ratio</span></code> is set to <code class="docutils literal"><span class="pre">None</span></code>,
offsets are ignored in the matching.</p>
</div></blockquote>
<p><strong>offset_min_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The minimum tolerance for offset matching. See offset_ratio description
for an explanation of how the offset tolerance is determined. Note:
this parameter only influences the results if <code class="docutils literal"><span class="pre">offset_ratio</span></code> is not
<code class="docutils literal"><span class="pre">None</span></code>.</p>
</div></blockquote>
<p><strong>strict</strong> : bool</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">strict=False</span></code> (the default), threshold checks for onset, offset,
and pitch matching are performed using <code class="docutils literal"><span class="pre">&lt;=</span></code> (less than or equal). If
<code class="docutils literal"><span class="pre">strict=True</span></code>, the threshold checks are performed using <code class="docutils literal"><span class="pre">&lt;</span></code> (less
than).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>matching</strong> : list of tuples</p>
<blockquote class="last">
<div><p>A list of matched reference and estimated notes.
<code class="docutils literal"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> where reference note <code class="docutils literal"><span class="pre">i</span></code> matches estimated
note <code class="docutils literal"><span class="pre">j</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription.precision_recall_f1_overlap">
<code class="descclassname">mir_eval.transcription.</code><code class="descname">precision_recall_f1_overlap</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_pitches</em>, <em>est_intervals</em>, <em>est_pitches</em>, <em>onset_tolerance=0.05</em>, <em>pitch_tolerance=50.0</em>, <em>offset_ratio=0.2</em>, <em>offset_min_tolerance=0.05</em>, <em>strict=False</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.precision_recall_f1_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Precision, Recall and F-measure of correct vs incorrectly
transcribed notes, and the Average Overlap Ratio for correctly transcribed
notes (see <a class="reference internal" href="#mir_eval.transcription.average_overlap_ratio" title="mir_eval.transcription.average_overlap_ratio"><code class="xref py py-func docutils literal"><span class="pre">average_overlap_ratio()</span></code></a>). “Correctness” is determined
based on note onset, pitch and (optionally) offset: an estimated note is
assumed correct if its onset is within +-50ms of a reference note and its
pitch (F0) is within +- quarter tone (50 cents) of the corresponding
reference note. If <code class="docutils literal"><span class="pre">offset_ratio</span></code> is <code class="docutils literal"><span class="pre">None</span></code>, note offsets are ignored
in the comparison. Otherwise, on top of the above requirements, a correct
returned note is required to have an offset value within 20% (by default,
adjustable via the <code class="docutils literal"><span class="pre">offset_ratio</span></code> parameter) of the reference note’s
duration around the reference note’s offset, or within
<code class="docutils literal"><span class="pre">offset_min_tolerance</span></code> (50 ms by default), whichever is larger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>ref_pitches</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of reference pitch values in Hertz</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_pitches</strong> : np.ndarray, shape=(m,)</p>
<blockquote>
<div><p>Array of estimated pitch values in Hertz</p>
</div></blockquote>
<p><strong>onset_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The tolerance for an estimated note’s onset deviating from the
reference note’s onset, in seconds. Default is 0.05 (50 ms).</p>
</div></blockquote>
<p><strong>pitch_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The tolerance for an estimated note’s pitch deviating from the
reference note’s pitch, in cents. Default is 50.0 (50 cents).</p>
</div></blockquote>
<p><strong>offset_ratio</strong> : float &gt; 0 or None</p>
<blockquote>
<div><p>The ratio of the reference note’s duration used to define the
offset_tolerance. Default is 0.2 (20%), meaning the
<code class="docutils literal"><span class="pre">offset_tolerance</span></code> will equal the <code class="docutils literal"><span class="pre">ref_duration</span> <span class="pre">*</span> <span class="pre">0.2</span></code>, or
<code class="docutils literal"><span class="pre">offset_min_tolerance</span></code> (0.05 by default, i.e. 50 ms), whichever is
greater. If <code class="docutils literal"><span class="pre">offset_ratio</span></code> is set to <code class="docutils literal"><span class="pre">None</span></code>, offsets are ignored in
the evaluation.</p>
</div></blockquote>
<p><strong>offset_min_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The minimum tolerance for offset matching. See <code class="docutils literal"><span class="pre">offset_ratio</span></code>
description for an explanation of how the offset tolerance is
determined. Note: this parameter only influences the results if
<code class="docutils literal"><span class="pre">offset_ratio</span></code> is not <code class="docutils literal"><span class="pre">None</span></code>.</p>
</div></blockquote>
<p><strong>strict</strong> : bool</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">strict=False</span></code> (the default), threshold checks for onset, offset,
and pitch matching are performed using <code class="docutils literal"><span class="pre">&lt;=</span></code> (less than or equal). If
<code class="docutils literal"><span class="pre">strict=True</span></code>, the threshold checks are performed using <code class="docutils literal"><span class="pre">&lt;</span></code> (less
than).</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>Weighting factor for f-measure (default value = 1.0).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>precision</strong> : float</p>
<blockquote>
<div><p>The computed precision score</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote>
<div><p>The computed recall score</p>
</div></blockquote>
<p><strong>f_measure</strong> : float</p>
<blockquote>
<div><p>The computed F-measure score</p>
</div></blockquote>
<p><strong>avg_overlap_ratio</strong> : float</p>
<blockquote class="last">
<div><p>The computed Average Overlap Ratio score</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">precision</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">recall</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">f_measure</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">precision_recall_f1_overlap</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">precision_no_offset</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">recall_no_offset</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">f_measure_no_offset</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>     <span class="n">mir_eval</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">precision_recall_f1_overlap</span><span class="p">(</span>
<span class="gp">... </span>         <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span><span class="p">,</span>
<span class="gp">... </span>         <span class="n">offset_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription.average_overlap_ratio">
<code class="descclassname">mir_eval.transcription.</code><code class="descname">average_overlap_ratio</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>est_intervals</em>, <em>matching</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.average_overlap_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Average Overlap Ratio between a reference and estimated
note transcription. Given a reference and corresponding estimated note,
their overlap ratio (OR) is defined as the ratio between the duration of
the time segment in which the two notes overlap and the time segment
spanned by the two notes combined (earliest onset to latest offset):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">OR</span> <span class="o">=</span> <span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">ref_offset</span><span class="p">,</span> <span class="n">est_offset</span><span class="p">)</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">ref_onset</span><span class="p">,</span> <span class="n">est_onset</span><span class="p">))</span> <span class="o">/</span>
<span class="gp">... </span>    <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ref_offset</span><span class="p">,</span> <span class="n">est_offset</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">ref_onset</span><span class="p">,</span> <span class="n">est_onset</span><span class="p">)))</span>
</pre></div>
</div>
<p>The Average Overlap Ratio (AOR) is given by the mean OR computed over all
matching reference and estimated notes. The metric goes from 0 (worst) to 1
(best).</p>
<p>Note: this function assumes the matching of reference and estimated notes
(see <a class="reference internal" href="#mir_eval.transcription.match_notes" title="mir_eval.transcription.match_notes"><code class="xref py py-func docutils literal"><span class="pre">match_notes()</span></code></a>) has already been performed and is provided by the
<code class="docutils literal"><span class="pre">matching</span></code> parameter. Furthermore, it is highly recommended to validate
the intervals (see <a class="reference internal" href="#mir_eval.transcription.validate_intervals" title="mir_eval.transcription.validate_intervals"><code class="xref py py-func docutils literal"><span class="pre">validate_intervals()</span></code></a>) before calling this
function, otherwise it is possible (though unlikely) for this function to
attempt a divide-by-zero operation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>matching</strong> : list of tuples</p>
<blockquote>
<div><p>A list of matched reference and estimated notes.
<code class="docutils literal"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> where reference note <code class="docutils literal"><span class="pre">i</span></code> matches estimated
note <code class="docutils literal"><span class="pre">j</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>avg_overlap_ratio</strong> : float</p>
<blockquote class="last">
<div><p>The computed Average Overlap Ratio score</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription.onset_precision_recall_f1">
<code class="descclassname">mir_eval.transcription.</code><code class="descname">onset_precision_recall_f1</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>est_intervals</em>, <em>onset_tolerance=0.05</em>, <em>strict=False</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.onset_precision_recall_f1" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Precision, Recall and F-measure of note onsets: an estimated
onset is considered correct if it is within +-50ms of a reference onset.
Note that this metric completely ignores note offset and note pitch. This
means an estimated onset will be considered correct if it matches a
reference onset, even if the onsets come from notes with completely
different pitches (i.e. notes that would not match with
<a class="reference internal" href="#mir_eval.transcription.match_notes" title="mir_eval.transcription.match_notes"><code class="xref py py-func docutils literal"><span class="pre">match_notes()</span></code></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>onset_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The tolerance for an estimated note’s onset deviating from the
reference note’s onset, in seconds. Default is 0.05 (50 ms).</p>
</div></blockquote>
<p><strong>strict</strong> : bool</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">strict=False</span></code> (the default), threshold checks for onset matching
are performed using <code class="docutils literal"><span class="pre">&lt;=</span></code> (less than or equal). If <code class="docutils literal"><span class="pre">strict=True</span></code>,
the threshold checks are performed using <code class="docutils literal"><span class="pre">&lt;</span></code> (less than).</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>Weighting factor for f-measure (default value = 1.0).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>precision</strong> : float</p>
<blockquote>
<div><p>The computed precision score</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote>
<div><p>The computed recall score</p>
</div></blockquote>
<p><strong>f_measure</strong> : float</p>
<blockquote class="last">
<div><p>The computed F-measure score</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">onset_precision</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">onset_recall</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">onset_f_measure</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">onset_precision_recall_f1</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription.offset_precision_recall_f1">
<code class="descclassname">mir_eval.transcription.</code><code class="descname">offset_precision_recall_f1</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>est_intervals</em>, <em>offset_ratio=0.2</em>, <em>offset_min_tolerance=0.05</em>, <em>strict=False</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.offset_precision_recall_f1" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Precision, Recall and F-measure of note offsets: an
estimated offset is considered correct if it is within +-50ms (or 20% of
the ref note duration, which ever is greater) of a reference offset. Note
that this metric completely ignores note onsets and note pitch. This means
an estimated offset will be considered correct if it matches a
reference offset, even if the offsets come from notes with completely
different pitches (i.e. notes that would not match with
<a class="reference internal" href="#mir_eval.transcription.match_notes" title="mir_eval.transcription.match_notes"><code class="xref py py-func docutils literal"><span class="pre">match_notes()</span></code></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>offset_ratio</strong> : float &gt; 0 or None</p>
<blockquote>
<div><p>The ratio of the reference note’s duration used to define the
offset_tolerance. Default is 0.2 (20%), meaning the
<code class="docutils literal"><span class="pre">offset_tolerance</span></code> will equal the <code class="docutils literal"><span class="pre">ref_duration</span> <span class="pre">*</span> <span class="pre">0.2</span></code>, or
<code class="docutils literal"><span class="pre">offset_min_tolerance</span></code> (0.05 by default, i.e. 50 ms), whichever is
greater.</p>
</div></blockquote>
<p><strong>offset_min_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The minimum tolerance for offset matching. See <code class="docutils literal"><span class="pre">offset_ratio</span></code>
description for an explanation of how the offset tolerance is
determined.</p>
</div></blockquote>
<p><strong>strict</strong> : bool</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">strict=False</span></code> (the default), threshold checks for onset matching
are performed using <code class="docutils literal"><span class="pre">&lt;=</span></code> (less than or equal). If <code class="docutils literal"><span class="pre">strict=True</span></code>,
the threshold checks are performed using <code class="docutils literal"><span class="pre">&lt;</span></code> (less than).</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>Weighting factor for f-measure (default value = 1.0).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>precision</strong> : float</p>
<blockquote>
<div><p>The computed precision score</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote>
<div><p>The computed recall score</p>
</div></blockquote>
<p><strong>f_measure</strong> : float</p>
<blockquote class="last">
<div><p>The computed F-measure score</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">offset_precision</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">offset_recall</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">offset_f_measure</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">offset_precision_recall_f1</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription.evaluate">
<code class="descclassname">mir_eval.transcription.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_pitches</em>, <em>est_intervals</em>, <em>est_pitches</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>ref_pitches</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of reference pitch values in Hertz</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_pitches</strong> : np.ndarray, shape=(m,)</p>
<blockquote>
<div><p>Array of estimated pitch values in Hertz</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>   <span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>   <span class="s1">&#39;estimate.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.transcription_velocity">
<span id="mir-eval-transcription-velocity"></span><h3><a class="reference internal" href="#module-mir_eval.transcription_velocity" title="mir_eval.transcription_velocity"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.transcription_velocity</span></code></a><a class="headerlink" href="#module-mir_eval.transcription_velocity" title="Permalink to this headline">¶</a></h3>
<p>Transcription evaluation, as defined in <a class="reference internal" href="#module-mir_eval.transcription" title="mir_eval.transcription"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.transcription</span></code></a>, does not
take into account the velocities of reference and estimated notes. This
submodule implements a variant of
<a class="reference internal" href="#mir_eval.transcription.precision_recall_f1_overlap" title="mir_eval.transcription.precision_recall_f1_overlap"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.transcription.precision_recall_f1_overlap()</span></code></a> which
additionally considers note velocity when determining whether a note is
correctly transcribed. This is done by defining a new function
<a class="reference internal" href="#mir_eval.transcription_velocity.match_notes" title="mir_eval.transcription_velocity.match_notes"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.transcription_velocity.match_notes()</span></code></a> which first calls
<a class="reference internal" href="#mir_eval.transcription.match_notes" title="mir_eval.transcription.match_notes"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.transcription.match_notes()</span></code></a> to get a note matching based on
onset, offset, and pitch. Then, we follow the evaluation procedure described in
<a class="footnote-reference" href="#hawthorne2018onsets" id="id43">[15]</a> to test whether an estimated note should be considered
correct:</p>
<ol class="arabic simple">
<li>Reference velocities are re-scaled to the range [0, 1].</li>
<li>A linear regression is performed to estimate global scale and offset
parameters which minimize the L2 distance between matched estimated and
(rescaled) reference notes.</li>
<li>The scale and offset parameters are used to rescale estimated
velocities.</li>
<li>An estimated/reference note pair which has been matched according to the
onset, offset, and pitch is further only considered correct if the rescaled
velocities are within a predefined threshold, defaulting to 0.1.</li>
</ol>
<p><a class="reference internal" href="#mir_eval.transcription_velocity.match_notes" title="mir_eval.transcription_velocity.match_notes"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.transcription_velocity.match_notes()</span></code></a> is used to define a new
variant <a class="reference internal" href="#mir_eval.transcription_velocity.precision_recall_f1_overlap" title="mir_eval.transcription_velocity.precision_recall_f1_overlap"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.transcription_velocity.precision_recall_f1_overlap()</span></code></a>
which considers velocity.</p>
<div class="section" id="id44">
<h4>Conventions<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h4>
<p>This submodule follows the conventions of <a class="reference internal" href="#module-mir_eval.transcription" title="mir_eval.transcription"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.transcription</span></code></a> and
additionally requires velocities to be provided as MIDI velocities in the range
[0, 127].</p>
</div>
<div class="section" id="id45">
<h4>Metrics<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.transcription_velocity.precision_recall_f1_overlap" title="mir_eval.transcription_velocity.precision_recall_f1_overlap"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.transcription_velocity.precision_recall_f1_overlap()</span></code></a>: The
precision, recall, F-measure, and Average Overlap Ratio of the note
transcription, where an estimated note is considered correct if its pitch,
onset, velocity and (optionally) offset are sufficiently close to a reference
note.</li>
</ul>
</div>
<div class="section" id="id46">
<h4>References<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><table class="docutils footnote" frame="void" id="hawthorne2018onsets" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id43">[15]</a></td><td>Curtis Hawthorne, Erich Elsen, Jialin Song, Adam
Roberts, Ian Simon, Colin Raffel, Jesse Engel, Sageev Oore, and Douglas
Eck, “Onsets and Frames: Dual-Objective Piano Transcription”, Proceedings
of the 19th International Society for Music Information Retrieval
Conference, 2018.</td></tr>
</tbody>
</table>
</div></blockquote>
<dl class="function">
<dt id="mir_eval.transcription_velocity.validate">
<code class="descclassname">mir_eval.transcription_velocity.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_pitches</em>, <em>ref_velocities</em>, <em>est_intervals</em>, <em>est_pitches</em>, <em>est_velocities</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription_velocity.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations have valid time intervals, pitches,
and velocities, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>ref_pitches</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of reference pitch values in Hertz</p>
</div></blockquote>
<p><strong>ref_velocities</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of MIDI velocities (i.e. between 0 and 127) of reference notes</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_pitches</strong> : np.ndarray, shape=(m,)</p>
<blockquote>
<div><p>Array of estimated pitch values in Hertz</p>
</div></blockquote>
<p><strong>est_velocities</strong> : np.ndarray, shape=(m,)</p>
<blockquote class="last">
<div><p>Array of MIDI velocities (i.e. between 0 and 127) of estimated notes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription_velocity.match_notes">
<code class="descclassname">mir_eval.transcription_velocity.</code><code class="descname">match_notes</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_pitches</em>, <em>ref_velocities</em>, <em>est_intervals</em>, <em>est_pitches</em>, <em>est_velocities</em>, <em>onset_tolerance=0.05</em>, <em>pitch_tolerance=50.0</em>, <em>offset_ratio=0.2</em>, <em>offset_min_tolerance=0.05</em>, <em>strict=False</em>, <em>velocity_tolerance=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription_velocity.match_notes" title="Permalink to this definition">¶</a></dt>
<dd><p>Match notes, taking note velocity into consideration.</p>
<p>This function first calls <a class="reference internal" href="#mir_eval.transcription.match_notes" title="mir_eval.transcription.match_notes"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.transcription.match_notes()</span></code></a> to
match notes according to the supplied intervals, pitches, onset, offset,
and pitch tolerances. The velocities of the matched notes are then used to
estimate a slope and intercept which can rescale the estimated velocities
so that they are as close as possible (in L2 sense) to their matched
reference velocities. Velocities are then normalized to the range [0, 1]. A
estimated note is then further only considered correct if its velocity is
within <code class="docutils literal"><span class="pre">velocity_tolerance</span></code> of its matched (according to pitch and
timing) reference note.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>ref_pitches</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of reference pitch values in Hertz</p>
</div></blockquote>
<p><strong>ref_velocities</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of MIDI velocities (i.e. between 0 and 127) of reference notes</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_pitches</strong> : np.ndarray, shape=(m,)</p>
<blockquote>
<div><p>Array of estimated pitch values in Hertz</p>
</div></blockquote>
<p><strong>est_velocities</strong> : np.ndarray, shape=(m,)</p>
<blockquote>
<div><p>Array of MIDI velocities (i.e. between 0 and 127) of estimated notes</p>
</div></blockquote>
<p><strong>onset_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The tolerance for an estimated note’s onset deviating from the
reference note’s onset, in seconds. Default is 0.05 (50 ms).</p>
</div></blockquote>
<p><strong>pitch_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The tolerance for an estimated note’s pitch deviating from the
reference note’s pitch, in cents. Default is 50.0 (50 cents).</p>
</div></blockquote>
<p><strong>offset_ratio</strong> : float &gt; 0 or None</p>
<blockquote>
<div><p>The ratio of the reference note’s duration used to define the
offset_tolerance. Default is 0.2 (20%), meaning the
<code class="docutils literal"><span class="pre">offset_tolerance</span></code> will equal the <code class="docutils literal"><span class="pre">ref_duration</span> <span class="pre">*</span> <span class="pre">0.2</span></code>, or 0.05 (50
ms), whichever is greater. If <code class="docutils literal"><span class="pre">offset_ratio</span></code> is set to <code class="docutils literal"><span class="pre">None</span></code>,
offsets are ignored in the matching.</p>
</div></blockquote>
<p><strong>offset_min_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The minimum tolerance for offset matching. See offset_ratio description
for an explanation of how the offset tolerance is determined. Note:
this parameter only influences the results if <code class="docutils literal"><span class="pre">offset_ratio</span></code> is not
<code class="docutils literal"><span class="pre">None</span></code>.</p>
</div></blockquote>
<p><strong>strict</strong> : bool</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">strict=False</span></code> (the default), threshold checks for onset, offset,
and pitch matching are performed using <code class="docutils literal"><span class="pre">&lt;=</span></code> (less than or equal). If
<code class="docutils literal"><span class="pre">strict=True</span></code>, the threshold checks are performed using <code class="docutils literal"><span class="pre">&lt;</span></code> (less
than).</p>
</div></blockquote>
<p><strong>velocity_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>Estimated notes are considered correct if, after rescaling and
normalization to [0, 1], they are within <code class="docutils literal"><span class="pre">velocity_tolerance</span></code> of a
matched reference note.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>matching</strong> : list of tuples</p>
<blockquote class="last">
<div><p>A list of matched reference and estimated notes.
<code class="docutils literal"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> where reference note <code class="docutils literal"><span class="pre">i</span></code> matches estimated
note <code class="docutils literal"><span class="pre">j</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription_velocity.precision_recall_f1_overlap">
<code class="descclassname">mir_eval.transcription_velocity.</code><code class="descname">precision_recall_f1_overlap</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_pitches</em>, <em>ref_velocities</em>, <em>est_intervals</em>, <em>est_pitches</em>, <em>est_velocities</em>, <em>onset_tolerance=0.05</em>, <em>pitch_tolerance=50.0</em>, <em>offset_ratio=0.2</em>, <em>offset_min_tolerance=0.05</em>, <em>strict=False</em>, <em>velocity_tolerance=0.1</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription_velocity.precision_recall_f1_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Precision, Recall and F-measure of correct vs incorrectly
transcribed notes, and the Average Overlap Ratio for correctly transcribed
notes (see <a class="reference internal" href="#mir_eval.transcription.average_overlap_ratio" title="mir_eval.transcription.average_overlap_ratio"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.transcription.average_overlap_ratio()</span></code></a>).
“Correctness” is determined based on note onset, velocity, pitch and
(optionally) offset. An estimated note is considered correct if</p>
<ol class="arabic simple">
<li>Its onset is within <code class="docutils literal"><span class="pre">onset_tolerance</span></code> (default +-50ms) of a
reference note</li>
<li>Its pitch (F0) is within +/- <code class="docutils literal"><span class="pre">pitch_tolerance</span></code> (default one
quarter tone, 50 cents) of the corresponding reference note</li>
<li>Its velocity, after normalizing reference velocities to the range
[0, 1] and globally rescaling estimated velocities to minimize L2
distance between matched reference notes, is within
<code class="docutils literal"><span class="pre">velocity_tolerance</span></code> (default 0.1) the corresponding reference note</li>
<li>If <code class="docutils literal"><span class="pre">offset_ratio</span></code> is <code class="docutils literal"><span class="pre">None</span></code>, note offsets are ignored in the
comparison. Otherwise, on top of the above requirements, a correct
returned note is required to have an offset value within
<cite>offset_ratio`</cite> (default 20%) of the reference note’s duration around
the reference note’s offset, or within <code class="docutils literal"><span class="pre">offset_min_tolerance</span></code>
(default 50 ms), whichever is larger.</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>ref_pitches</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of reference pitch values in Hertz</p>
</div></blockquote>
<p><strong>ref_velocities</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of MIDI velocities (i.e. between 0 and 127) of reference notes</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_pitches</strong> : np.ndarray, shape=(m,)</p>
<blockquote>
<div><p>Array of estimated pitch values in Hertz</p>
</div></blockquote>
<p><strong>est_velocities</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of MIDI velocities (i.e. between 0 and 127) of estimated notes</p>
</div></blockquote>
<p><strong>onset_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The tolerance for an estimated note’s onset deviating from the
reference note’s onset, in seconds. Default is 0.05 (50 ms).</p>
</div></blockquote>
<p><strong>pitch_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The tolerance for an estimated note’s pitch deviating from the
reference note’s pitch, in cents. Default is 50.0 (50 cents).</p>
</div></blockquote>
<p><strong>offset_ratio</strong> : float &gt; 0 or None</p>
<blockquote>
<div><p>The ratio of the reference note’s duration used to define the
offset_tolerance. Default is 0.2 (20%), meaning the
<code class="docutils literal"><span class="pre">offset_tolerance</span></code> will equal the <code class="docutils literal"><span class="pre">ref_duration</span> <span class="pre">*</span> <span class="pre">0.2</span></code>, or
<code class="docutils literal"><span class="pre">offset_min_tolerance</span></code> (0.05 by default, i.e. 50 ms), whichever is
greater. If <code class="docutils literal"><span class="pre">offset_ratio</span></code> is set to <code class="docutils literal"><span class="pre">None</span></code>, offsets are ignored in
the evaluation.</p>
</div></blockquote>
<p><strong>offset_min_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The minimum tolerance for offset matching. See <code class="docutils literal"><span class="pre">offset_ratio</span></code>
description for an explanation of how the offset tolerance is
determined. Note: this parameter only influences the results if
<code class="docutils literal"><span class="pre">offset_ratio</span></code> is not <code class="docutils literal"><span class="pre">None</span></code>.</p>
</div></blockquote>
<p><strong>strict</strong> : bool</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">strict=False</span></code> (the default), threshold checks for onset, offset,
and pitch matching are performed using <code class="docutils literal"><span class="pre">&lt;=</span></code> (less than or equal). If
<code class="docutils literal"><span class="pre">strict=True</span></code>, the threshold checks are performed using <code class="docutils literal"><span class="pre">&lt;</span></code> (less
than).</p>
</div></blockquote>
<p><strong>velocity_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>Estimated notes are considered correct if, after rescaling and
normalization to [0, 1], they are within <code class="docutils literal"><span class="pre">velocity_tolerance</span></code> of a
matched reference note.</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>Weighting factor for f-measure (default value = 1.0).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>precision</strong> : float</p>
<blockquote>
<div><p>The computed precision score</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote>
<div><p>The computed recall score</p>
</div></blockquote>
<p><strong>f_measure</strong> : float</p>
<blockquote>
<div><p>The computed F-measure score</p>
</div></blockquote>
<p><strong>avg_overlap_ratio</strong> : float</p>
<blockquote class="last">
<div><p>The computed Average Overlap Ratio score</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription_velocity.evaluate">
<code class="descclassname">mir_eval.transcription_velocity.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_pitches</em>, <em>ref_velocities</em>, <em>est_intervals</em>, <em>est_pitches</em>, <em>est_velocities</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription_velocity.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>ref_pitches</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of reference pitch values in Hertz</p>
</div></blockquote>
<p><strong>ref_velocities</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of MIDI velocities (i.e. between 0 and 127) of reference notes</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_pitches</strong> : np.ndarray, shape=(m,)</p>
<blockquote>
<div><p>Array of estimated pitch values in Hertz</p>
</div></blockquote>
<p><strong>est_velocities</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of MIDI velocities (i.e. between 0 and 127) of estimated notes</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.key">
<span id="mir-eval-key"></span><h3><a class="reference internal" href="#module-mir_eval.key" title="mir_eval.key"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.key</span></code></a><a class="headerlink" href="#module-mir_eval.key" title="Permalink to this headline">¶</a></h3>
<p>Key Detection involves determining the underlying key (distribution of notes
and note transitions) in a piece of music.  Key detection algorithms are
evaluated by comparing their estimated key to a ground-truth reference key and
reporting a score according to the relationship of the keys.</p>
<div class="section" id="id47">
<h4>Conventions<a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h4>
<p>Keys are represented as strings of the form <code class="docutils literal"><span class="pre">'(key)</span> <span class="pre">(mode)'</span></code>, e.g. <code class="docutils literal"><span class="pre">'C#</span>
<span class="pre">major'</span></code> or <code class="docutils literal"><span class="pre">'Fb</span> <span class="pre">minor'</span></code>.  The case of the key is ignored.  Note that certain
key strings are equivalent, e.g. <code class="docutils literal"><span class="pre">'C#</span> <span class="pre">major'</span></code> and <code class="docutils literal"><span class="pre">'Db</span> <span class="pre">major'</span></code>.  The mode
may only be specified as either <code class="docutils literal"><span class="pre">'major'</span></code> or <code class="docutils literal"><span class="pre">'minor'</span></code>, no other mode
strings will be accepted.</p>
</div>
<div class="section" id="id48">
<h4>Metrics<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.key.weighted_score" title="mir_eval.key.weighted_score"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.key.weighted_score()</span></code></a>: Heuristic scoring of the relation of two
keys.</li>
</ul>
<dl class="function">
<dt id="mir_eval.key.validate_key">
<code class="descclassname">mir_eval.key.</code><code class="descname">validate_key</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.validate_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that a key is well-formatted, e.g. in the form <code class="docutils literal"><span class="pre">'C#</span> <span class="pre">major'</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : str</p>
<blockquote class="last">
<div><p>Key to verify</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.key.validate">
<code class="descclassname">mir_eval.key.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>reference_key</em>, <em>estimated_key</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric are valid key strings and
throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_key</strong> : str</p>
<blockquote>
<div><p>Reference key string.</p>
</div></blockquote>
<p><strong>estimated_key</strong> : str</p>
<blockquote class="last">
<div><p>Estimated key string.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.key.split_key_string">
<code class="descclassname">mir_eval.key.</code><code class="descname">split_key_string</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.split_key_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits a key string (of the form, e.g. <code class="docutils literal"><span class="pre">'C#</span> <span class="pre">major'</span></code>), into a tuple of
<code class="docutils literal"><span class="pre">(key,</span> <span class="pre">mode)</span></code> where <code class="docutils literal"><span class="pre">key</span></code> is is an integer representing the semitone
distance from C.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : str</p>
<blockquote>
<div><p>String representing a key.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>key</strong> : int</p>
<blockquote>
<div><p>Number of semitones above C.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote class="last">
<div><p>String representing the mode.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.key.weighted_score">
<code class="descclassname">mir_eval.key.</code><code class="descname">weighted_score</code><span class="sig-paren">(</span><em>reference_key</em>, <em>estimated_key</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.weighted_score" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a heuristic score which is weighted according to the
relationship of the reference and estimated key, as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="89%" />
<col width="11%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Relationship</td>
<td>Score</td>
</tr>
<tr class="row-even"><td>Same key</td>
<td>1.0</td>
</tr>
<tr class="row-odd"><td>Estimated key is a perfect fifth above reference key</td>
<td>0.5</td>
</tr>
<tr class="row-even"><td>Relative major/minor</td>
<td>0.3</td>
</tr>
<tr class="row-odd"><td>Parallel major/minor</td>
<td>0.2</td>
</tr>
<tr class="row-even"><td>Other</td>
<td>0.0</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_key</strong> : str</p>
<blockquote>
<div><p>Reference key string.</p>
</div></blockquote>
<p><strong>estimated_key</strong> : str</p>
<blockquote>
<div><p>Estimated key string.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>score</strong> : float</p>
<blockquote class="last">
<div><p>Score representing how closely related the keys are.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_key</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_key</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_key</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_key</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">weighted_score</span><span class="p">(</span><span class="n">ref_key</span><span class="p">,</span> <span class="n">est_key</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.key.evaluate">
<code class="descclassname">mir_eval.key.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>reference_key</em>, <em>estimated_key</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_key</strong> : str</p>
<blockquote>
<div><p>Reference key string.</p>
</div></blockquote>
<p><strong>ref_key</strong> : str</p>
<blockquote>
<div><p>Estimated key string.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_key</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_key</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_key</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_key</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_key</span><span class="p">,</span> <span class="n">est_key</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.util">
<span id="mir-eval-util"></span><h3><a class="reference internal" href="#module-mir_eval.util" title="mir_eval.util"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.util</span></code></a><a class="headerlink" href="#module-mir_eval.util" title="Permalink to this headline">¶</a></h3>
<p>This submodule collects useful functionality required across the task
submodules, such as preprocessing, validation, and common computations.</p>
<dl class="function">
<dt id="mir_eval.util.index_labels">
<code class="descclassname">mir_eval.util.</code><code class="descname">index_labels</code><span class="sig-paren">(</span><em>labels</em>, <em>case_sensitive=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.index_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of string identifiers into numerical indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels</strong> : list of strings, shape=(n,)</p>
<blockquote>
<div><p>A list of annotations, e.g., segment or chord labels from an
annotation file.</p>
</div></blockquote>
<p><strong>case_sensitive</strong> : bool</p>
<blockquote>
<div><p>Set to True to enable case-sensitive label indexing
(Default value = False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>indices</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>Numerical representation of <code class="docutils literal"><span class="pre">labels</span></code></p>
</div></blockquote>
<p><strong>index_to_label</strong> : dict</p>
<blockquote class="last">
<div><p>Mapping to convert numerical indices back to labels.
<code class="docutils literal"><span class="pre">labels[i]</span> <span class="pre">==</span> <span class="pre">index_to_label[indices[i]]</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.generate_labels">
<code class="descclassname">mir_eval.util.</code><code class="descname">generate_labels</code><span class="sig-paren">(</span><em>items</em>, <em>prefix='__'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.generate_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array of items (e.g. events, intervals), create a synthetic label
for each event of the form ‘(label prefix)(item number)’</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>items</strong> : list-like</p>
<blockquote>
<div><p>A list or array of events or intervals</p>
</div></blockquote>
<p><strong>prefix</strong> : str</p>
<blockquote>
<div><p>This prefix will be prepended to all synthetically generated labels
(Default value = ‘__’)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>labels</strong> : list of str</p>
<blockquote class="last">
<div><p>Synthetically generated labels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.intervals_to_samples">
<code class="descclassname">mir_eval.util.</code><code class="descname">intervals_to_samples</code><span class="sig-paren">(</span><em>intervals</em>, <em>labels</em>, <em>offset=0</em>, <em>sample_size=0.1</em>, <em>fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.intervals_to_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of labeled time intervals to annotated samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n, d)</p>
<blockquote>
<div><p>An array of time intervals, as returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.
The <code class="docutils literal"><span class="pre">i</span></code> th interval spans time <code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">0]</span></code> to
<code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">1]</span></code>.</p>
</div></blockquote>
<p><strong>labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>The annotation for each interval</p>
</div></blockquote>
<p><strong>offset</strong> : float &gt; 0</p>
<blockquote>
<div><p>Phase offset of the sampled time grid (in seconds)
(Default value = 0)</p>
</div></blockquote>
<p><strong>sample_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>duration of each sample to be generated (in seconds)
(Default value = 0.1)</p>
</div></blockquote>
<p><strong>fill_value</strong> : type(labels[0])</p>
<blockquote>
<div><p>Object to use for the label with out-of-range time points.
(Default value = None)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sample_times</strong> : list</p>
<blockquote>
<div><p>list of sample times</p>
</div></blockquote>
<p><strong>sample_labels</strong> : list</p>
<blockquote class="last">
<div><p>array of labels for each generated sample</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Intervals will be rounded down to the nearest multiple
of <code class="docutils literal"><span class="pre">sample_size</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.interpolate_intervals">
<code class="descclassname">mir_eval.util.</code><code class="descname">interpolate_intervals</code><span class="sig-paren">(</span><em>intervals</em>, <em>labels</em>, <em>time_points</em>, <em>fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.interpolate_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign labels to a set of points in time given a set of intervals.</p>
<p>Time points that do not lie within an interval are mapped to <cite>fill_value</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>An array of time intervals, as returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a>.
The <code class="docutils literal"><span class="pre">i</span></code> th interval spans time <code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">0]</span></code> to
<code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">1]</span></code>.</p>
<p>Intervals are assumed to be disjoint.</p>
</div></blockquote>
<p><strong>labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>The annotation for each interval</p>
</div></blockquote>
<p><strong>time_points</strong> : array_like, shape=(m,)</p>
<blockquote>
<div><p>Points in time to assign labels.  These must be in
non-decreasing order.</p>
</div></blockquote>
<p><strong>fill_value</strong> : type(labels[0])</p>
<blockquote>
<div><p>Object to use for the label with out-of-range time points.
(Default value = None)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>aligned_labels</strong> : list</p>
<blockquote>
<div><p>Labels corresponding to the given time points.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>If <cite>time_points</cite> is not in non-decreasing order.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.sort_labeled_intervals">
<code class="descclassname">mir_eval.util.</code><code class="descname">sort_labeled_intervals</code><span class="sig-paren">(</span><em>intervals</em>, <em>labels=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.sort_labeled_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort intervals, and optionally, their corresponding labels
according to start time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>The input intervals</p>
</div></blockquote>
<p><strong>labels</strong> : list, optional</p>
<blockquote>
<div><p>Labels for each interval</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">intervals_sorted or (intervals_sorted, labels_sorted)</p>
<blockquote class="last">
<div><p>Labels are only returned if provided as input</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.f_measure">
<code class="descclassname">mir_eval.util.</code><code class="descname">f_measure</code><span class="sig-paren">(</span><em>precision</em>, <em>recall</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the f-measure from precision and recall scores.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>precision</strong> : float in (0, 1]</p>
<blockquote>
<div><p>Precision</p>
</div></blockquote>
<p><strong>recall</strong> : float in (0, 1]</p>
<blockquote>
<div><p>Recall</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>Weighting factor for f-measure
(Default value = 1.0)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_measure</strong> : float</p>
<blockquote class="last">
<div><p>The weighted f-measure</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.intervals_to_boundaries">
<code class="descclassname">mir_eval.util.</code><code class="descname">intervals_to_boundaries</code><span class="sig-paren">(</span><em>intervals</em>, <em>q=5</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.intervals_to_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert interval times into boundaries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n_events, 2)</p>
<blockquote>
<div><p>Array of interval start and end-times</p>
</div></blockquote>
<p><strong>q</strong> : int</p>
<blockquote>
<div><p>Number of decimals to round to. (Default value = 5)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>boundaries</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Interval boundary times, including the end of the final interval</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.boundaries_to_intervals">
<code class="descclassname">mir_eval.util.</code><code class="descname">boundaries_to_intervals</code><span class="sig-paren">(</span><em>boundaries</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.boundaries_to_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of event times into intervals</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>boundaries</strong> : list-like</p>
<blockquote>
<div><p>List-like of event times.  These are assumed to be unique
timestamps in ascending order.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n_intervals, 2)</p>
<blockquote class="last">
<div><p>Start and end time for each interval</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.adjust_intervals">
<code class="descclassname">mir_eval.util.</code><code class="descname">adjust_intervals</code><span class="sig-paren">(</span><em>intervals</em>, <em>labels=None</em>, <em>t_min=0.0</em>, <em>t_max=None</em>, <em>start_label='__T_MIN'</em>, <em>end_label='__T_MAX'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.adjust_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust a list of time intervals to span the range <code class="docutils literal"><span class="pre">[t_min,</span> <span class="pre">t_max]</span></code>.</p>
<p>Any intervals lying completely outside the specified range will be removed.</p>
<p>Any intervals lying partially outside the specified range will be cropped.</p>
<p>If the specified range exceeds the span of the provided data in either
direction, additional intervals will be appended.  If an interval is
appended at the beginning, it will be given the label <code class="docutils literal"><span class="pre">start_label</span></code>; if
an interval is appended at the end, it will be given the label
<code class="docutils literal"><span class="pre">end_label</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n_events, 2)</p>
<blockquote>
<div><p>Array of interval start and end-times</p>
</div></blockquote>
<p><strong>labels</strong> : list, len=n_events or None</p>
<blockquote>
<div><p>List of labels
(Default value = None)</p>
</div></blockquote>
<p><strong>t_min</strong> : float or None</p>
<blockquote>
<div><p>Minimum interval start time.
(Default value = 0.0)</p>
</div></blockquote>
<p><strong>t_max</strong> : float or None</p>
<blockquote>
<div><p>Maximum interval end time.
(Default value = None)</p>
</div></blockquote>
<p><strong>start_label</strong> : str or float or int</p>
<blockquote>
<div><p>Label to give any intervals appended at the beginning
(Default value = ‘__T_MIN’)</p>
</div></blockquote>
<p><strong>end_label</strong> : str or float or int</p>
<blockquote>
<div><p>Label to give any intervals appended at the end
(Default value = ‘__T_MAX’)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>new_intervals</strong> : np.ndarray</p>
<blockquote>
<div><p>Intervals spanning <code class="docutils literal"><span class="pre">[t_min,</span> <span class="pre">t_max]</span></code></p>
</div></blockquote>
<p><strong>new_labels</strong> : list</p>
<blockquote class="last">
<div><p>List of labels for <code class="docutils literal"><span class="pre">new_labels</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.adjust_events">
<code class="descclassname">mir_eval.util.</code><code class="descname">adjust_events</code><span class="sig-paren">(</span><em>events</em>, <em>labels=None</em>, <em>t_min=0.0</em>, <em>t_max=None</em>, <em>label_prefix='__'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.adjust_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust the given list of event times to span the range
<code class="docutils literal"><span class="pre">[t_min,</span> <span class="pre">t_max]</span></code>.</p>
<p>Any event times outside of the specified range will be removed.</p>
<p>If the times do not span <code class="docutils literal"><span class="pre">[t_min,</span> <span class="pre">t_max]</span></code>, additional events will be
added with the prefix <code class="docutils literal"><span class="pre">label_prefix</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>events</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of event times (seconds)</p>
</div></blockquote>
<p><strong>labels</strong> : list or None</p>
<blockquote>
<div><p>List of labels
(Default value = None)</p>
</div></blockquote>
<p><strong>t_min</strong> : float or None</p>
<blockquote>
<div><p>Minimum valid event time.
(Default value = 0.0)</p>
</div></blockquote>
<p><strong>t_max</strong> : float or None</p>
<blockquote>
<div><p>Maximum valid event time.
(Default value = None)</p>
</div></blockquote>
<p><strong>label_prefix</strong> : str</p>
<blockquote>
<div><p>Prefix string to use for synthetic labels
(Default value = ‘__’)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>new_times</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Event times corrected to the given range.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.intersect_files">
<code class="descclassname">mir_eval.util.</code><code class="descname">intersect_files</code><span class="sig-paren">(</span><em>flist1</em>, <em>flist2</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.intersect_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intersection of two sets of filepaths, based on the file name
(after the final ‘/’) and ignoring the file extension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>flist1</strong> : list</p>
<blockquote>
<div><p>first list of filepaths</p>
</div></blockquote>
<p><strong>flist2</strong> : list</p>
<blockquote>
<div><p>second list of filepaths</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sublist1</strong> : list</p>
<blockquote>
<div><p>subset of filepaths with matching stems from <code class="docutils literal"><span class="pre">flist1</span></code></p>
</div></blockquote>
<p><strong>sublist2</strong> : list</p>
<blockquote class="last">
<div><p>corresponding filepaths from <code class="docutils literal"><span class="pre">flist2</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flist1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;/a/b/abc.lab&#39;</span><span class="p">,</span> <span class="s1">&#39;/c/d/123.lab&#39;</span><span class="p">,</span> <span class="s1">&#39;/e/f/xyz.lab&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flist2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;/g/h/xyz.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;/i/j/123.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;/k/l/456.lab&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sublist1</span><span class="p">,</span> <span class="n">sublist2</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intersect_files</span><span class="p">(</span><span class="n">flist1</span><span class="p">,</span> <span class="n">flist2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">sublist1</span>
<span class="go">[&#39;/e/f/xyz.lab&#39;, &#39;/c/d/123.lab&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">sublist2</span>
<span class="go">[&#39;/g/h/xyz.npy&#39;, &#39;/i/j/123.txt&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.merge_labeled_intervals">
<code class="descclassname">mir_eval.util.</code><code class="descname">merge_labeled_intervals</code><span class="sig-paren">(</span><em>x_intervals</em>, <em>x_labels</em>, <em>y_intervals</em>, <em>y_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.merge_labeled_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the time intervals of two sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x_intervals</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of interval times (seconds)</p>
</div></blockquote>
<p><strong>x_labels</strong> : list or None</p>
<blockquote>
<div><p>List of labels</p>
</div></blockquote>
<p><strong>y_intervals</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of interval times (seconds)</p>
</div></blockquote>
<p><strong>y_labels</strong> : list or None</p>
<blockquote>
<div><p>List of labels</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>new_intervals</strong> : np.ndarray</p>
<blockquote>
<div><p>New interval times of the merged sequences.</p>
</div></blockquote>
<p><strong>new_x_labels</strong> : list</p>
<blockquote>
<div><p>New labels for the sequence <code class="docutils literal"><span class="pre">x</span></code></p>
</div></blockquote>
<p><strong>new_y_labels</strong> : list</p>
<blockquote class="last">
<div><p>New labels for the sequence <code class="docutils literal"><span class="pre">y</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.match_events">
<code class="descclassname">mir_eval.util.</code><code class="descname">match_events</code><span class="sig-paren">(</span><em>ref</em>, <em>est</em>, <em>window</em>, <em>distance=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.match_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a maximum matching between reference and estimated event times,
subject to a window constraint.</p>
<p>Given two lists of event times <code class="docutils literal"><span class="pre">ref</span></code> and <code class="docutils literal"><span class="pre">est</span></code>, we seek the largest set
of correspondences <code class="docutils literal"><span class="pre">(ref[i],</span> <span class="pre">est[j])</span></code> such that
<code class="docutils literal"><span class="pre">distance(ref[i],</span> <span class="pre">est[j])</span> <span class="pre">&lt;=</span> <span class="pre">window</span></code>, and each
<code class="docutils literal"><span class="pre">ref[i]</span></code> and <code class="docutils literal"><span class="pre">est[j]</span></code> is matched at most once.</p>
<p>This is useful for computing precision/recall metrics in beat tracking,
onset detection, and segmentation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of reference values</p>
</div></blockquote>
<p><strong>est</strong> : np.ndarray, shape=(m,)</p>
<blockquote>
<div><p>Array of estimated values</p>
</div></blockquote>
<p><strong>window</strong> : float &gt; 0</p>
<blockquote>
<div><p>Size of the window.</p>
</div></blockquote>
<p><strong>distance</strong> : function</p>
<blockquote>
<div><p>function that computes the outer distance of ref and est.
By default uses <code class="docutils literal"><span class="pre">|ref[i]</span> <span class="pre">-</span> <span class="pre">est[j]|</span></code></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>matching</strong> : list of tuples</p>
<blockquote class="last">
<div><p>A list of matched reference and event numbers.
<code class="docutils literal"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> where <code class="docutils literal"><span class="pre">ref[i]</span></code> matches <code class="docutils literal"><span class="pre">est[j]</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.validate_intervals">
<code class="descclassname">mir_eval.util.</code><code class="descname">validate_intervals</code><span class="sig-paren">(</span><em>intervals</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.validate_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that an (n, 2) interval ndarray is well-formed, and raises errors
if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote class="last">
<div><p>Array of interval start/end locations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.validate_events">
<code class="descclassname">mir_eval.util.</code><code class="descname">validate_events</code><span class="sig-paren">(</span><em>events</em>, <em>max_time=30000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.validate_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that a 1-d event location ndarray is well-formed, and raises
errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>events</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of event times</p>
</div></blockquote>
<p><strong>max_time</strong> : float</p>
<blockquote class="last">
<div><p>If an event is found above this time, a ValueError will be raised.
(Default value = 30000.)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.validate_frequencies">
<code class="descclassname">mir_eval.util.</code><code class="descname">validate_frequencies</code><span class="sig-paren">(</span><em>frequencies</em>, <em>max_freq</em>, <em>min_freq</em>, <em>allow_negatives=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.validate_frequencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that a 1-d frequency ndarray is well-formed, and raises
errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>frequencies</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of frequency values</p>
</div></blockquote>
<p><strong>max_freq</strong> : float</p>
<blockquote>
<div><p>If a frequency is found above this pitch, a ValueError will be raised.
(Default value = 5000.)</p>
</div></blockquote>
<p><strong>min_freq</strong> : float</p>
<blockquote>
<div><p>If a frequency is found below this pitch, a ValueError will be raised.
(Default value = 20.)</p>
</div></blockquote>
<p><strong>allow_negatives</strong> : bool</p>
<blockquote class="last">
<div><p>Whether or not to allow negative frequency values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.has_kwargs">
<code class="descclassname">mir_eval.util.</code><code class="descname">has_kwargs</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.has_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether a function has **kwargs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>function</strong> : callable</p>
<blockquote>
<div><p>The function to test</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True if function accepts arbitrary keyword arguments.</p>
<p class="last">False otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.filter_kwargs">
<code class="descclassname">mir_eval.util.</code><code class="descname">filter_kwargs</code><span class="sig-paren">(</span><em>_function</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.filter_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a function and args and keyword args to pass to it, call the function
but using only the keyword arguments which it accepts.  This is equivalent
to redefining the function with an additional **kwargs to accept slop
keyword args.</p>
<p>If the target function already accepts **kwargs parameters, no filtering
is performed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>_function</strong> : callable</p>
<blockquote class="last">
<div><p>Function to call.  Can take in any number of args or kwargs</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.intervals_to_durations">
<code class="descclassname">mir_eval.util.</code><code class="descname">intervals_to_durations</code><span class="sig-paren">(</span><em>intervals</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.intervals_to_durations" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an array of n intervals to their n durations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>An array of time intervals, as returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a>.
The <code class="docutils literal"><span class="pre">i</span></code> th interval spans time <code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">0]</span></code> to
<code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">1]</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>durations</strong> : np.ndarray, shape=(n,)</p>
<blockquote class="last">
<div><p>Array of the duration of each interval.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.hz_to_midi">
<code class="descclassname">mir_eval.util.</code><code class="descname">hz_to_midi</code><span class="sig-paren">(</span><em>freqs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.hz_to_midi" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Hz to MIDI numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>freqs</strong> : number or ndarray</p>
<blockquote>
<div><p>Frequency/frequencies in Hz</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>midi</strong> : number or ndarray</p>
<blockquote class="last">
<div><p>MIDI note numbers corresponding to input frequencies.
Note that these may be fractional.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.midi_to_hz">
<code class="descclassname">mir_eval.util.</code><code class="descname">midi_to_hz</code><span class="sig-paren">(</span><em>midi</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.midi_to_hz" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert MIDI numbers to Hz</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>midi</strong> : number or ndarray</p>
<blockquote>
<div><p>MIDI notes</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>freqs</strong> : number or ndarray</p>
<blockquote class="last">
<div><p>Frequency/frequencies in Hz corresponding to <cite>midi</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-mir_eval.io">
<span id="mir-eval-io"></span><h3><a class="reference internal" href="#module-mir_eval.io" title="mir_eval.io"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.io</span></code></a><a class="headerlink" href="#module-mir_eval.io" title="Permalink to this headline">¶</a></h3>
<p>Functions for loading in annotations from files in different formats.</p>
<dl class="function">
<dt id="mir_eval.io.load_delimited">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_delimited</code><span class="sig-paren">(</span><em>filename</em>, <em>converters</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_delimited" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function for loading in data from an annotation file where columns
are delimited.  The number of columns is inferred from the length of
the provided converters list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>converters</strong> : list of functions</p>
<blockquote>
<div><p>Each entry in column <code class="docutils literal"><span class="pre">n</span></code> of the file will be cast by the function
<code class="docutils literal"><span class="pre">converters[n]</span></code>.</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>columns</strong> : tuple of lists</p>
<blockquote class="last">
<div><p>Each list in this tuple corresponds to values in one of the columns
in the file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load in a one-column list of event times (floats)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">load_delimited</span><span class="p">(</span><span class="s1">&#39;events.txt&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load in a list of labeled events, separated by commas</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">load_delimited</span><span class="p">(</span><span class="s1">&#39;labeled_events.csv&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="s1">&#39;,&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_events">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_events</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Import time-stamp events from an annotation file.  The file should
consist of a single column of numeric values corresponding to the event
times. This is primarily useful for processing events which lack duration,
such as beats or onsets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>event_times</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>array of event times (float)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_labeled_events">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_labeled_events</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_labeled_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Import labeled time-stamp events from an annotation file.  The file should
consist of two columns; the first having numeric values corresponding to
the event times and the second having string labels for each event.  This
is primarily useful for processing labeled events which lack duration, such
as beats with metric beat number or onsets with an instrument label.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>event_times</strong> : np.ndarray</p>
<blockquote>
<div><p>array of event times (float)</p>
</div></blockquote>
<p><strong>labels</strong> : list of str</p>
<blockquote class="last">
<div><p>list of labels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_intervals">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_intervals</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Import intervals from an annotation file.  The file should consist of two
columns of numeric values corresponding to start and end time of each
interval.  This is primarily useful for processing events which span a
duration, such as segmentation, chords, or instrument activation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n_events, 2)</p>
<blockquote class="last">
<div><p>array of event start and end times</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_labeled_intervals">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_labeled_intervals</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_labeled_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Import labeled intervals from an annotation file.  The file should consist
of three columns: Two consisting of numeric values corresponding to start
and end time of each interval and a third corresponding to the label of
each interval.  This is primarily useful for processing events which span a
duration, such as segmentation, chords, or instrument activation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n_events, 2)</p>
<blockquote>
<div><p>array of event start and end time</p>
</div></blockquote>
<p><strong>labels</strong> : list of str</p>
<blockquote class="last">
<div><p>list of labels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_time_series">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_time_series</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_time_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Import a time series from an annotation file.  The file should consist of
two columns of numeric values corresponding to the time and value of each
sample of the time series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>times</strong> : np.ndarray</p>
<blockquote>
<div><p>array of timestamps (float)</p>
</div></blockquote>
<p><strong>values</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>array of corresponding numeric values (float)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_patterns">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_patterns</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_patterns" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the patters contained in the filename and puts them into a list
of patterns, each pattern being a list of occurrence, and each
occurrence being a list of (onset, midi) pairs.</p>
<p>The input file must be formatted as described in MIREX 2013:
<a class="reference external" href="http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_%26_Sections">http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_%26_Sections</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>The input file path containing the patterns of a given piece using the
MIREX 2013 format.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pattern_list</strong> : list</p>
<blockquote class="last">
<div><p>The list of patterns, containing all their occurrences,
using the following format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">onset_midi</span> <span class="o">=</span> <span class="p">(</span><span class="n">onset_time</span><span class="p">,</span> <span class="n">midi_number</span><span class="p">)</span>
<span class="n">occurrence</span> <span class="o">=</span> <span class="p">[</span><span class="n">onset_midi1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">onset_midiO</span><span class="p">]</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="p">[</span><span class="n">occurrence1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">occurrenceM</span><span class="p">]</span>
<span class="n">pattern_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">pattern1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">patternN</span><span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">N</span></code> is the number of patterns, <code class="docutils literal"><span class="pre">M[i]</span></code> is the number of
occurrences of the <code class="docutils literal"><span class="pre">i</span></code> th pattern, and <code class="docutils literal"><span class="pre">O[j]</span></code> is the number of
onsets in the <code class="docutils literal"><span class="pre">j</span></code>’th occurrence.  E.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">occ1</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">64.0</span><span class="p">)]</span>
<span class="n">occ2</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">4.5</span><span class="p">,</span> <span class="mf">65.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">65.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">5.5</span><span class="p">,</span> <span class="mf">65.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">6.0</span><span class="p">,</span> <span class="mf">62.0</span><span class="p">)]</span>
<span class="n">pattern1</span> <span class="o">=</span> <span class="p">[</span><span class="n">occ1</span><span class="p">,</span> <span class="n">occ2</span><span class="p">]</span>

<span class="n">occ1</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">10.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">11.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">11.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">12.0</span><span class="p">,</span> <span class="mf">64.0</span><span class="p">),</span>
        <span class="p">(</span><span class="mf">12.5</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">13.0</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">13.5</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">14.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span>
        <span class="p">(</span><span class="mf">14.5</span><span class="p">,</span> <span class="mf">76.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">15.0</span><span class="p">,</span> <span class="mf">76.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">15.5</span><span class="p">,</span> <span class="mf">76.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">16.0</span><span class="p">,</span> <span class="mf">72.0</span><span class="p">)]</span>
<span class="n">occ2</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">18.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">19.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">19.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">62.0</span><span class="p">),</span>
        <span class="p">(</span><span class="mf">20.5</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">21.0</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">21.5</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">22.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span>
        <span class="p">(</span><span class="mf">22.5</span><span class="p">,</span> <span class="mf">77.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">23.0</span><span class="p">,</span> <span class="mf">77.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">23.5</span><span class="p">,</span> <span class="mf">77.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">24.0</span><span class="p">,</span> <span class="mf">74.0</span><span class="p">)]</span>
<span class="n">pattern2</span> <span class="o">=</span> <span class="p">[</span><span class="n">occ1</span><span class="p">,</span> <span class="n">occ2</span><span class="p">]</span>

<span class="n">pattern_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">pattern1</span><span class="p">,</span> <span class="n">pattern2</span><span class="p">]</span>
</pre></div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_wav">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_wav</code><span class="sig-paren">(</span><em>path</em>, <em>mono=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_wav" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a .wav file as a numpy array using <code class="docutils literal"><span class="pre">scipy.io.wavfile</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>path</strong> : str</p>
<blockquote>
<div><p>Path to a .wav file</p>
</div></blockquote>
<p><strong>mono</strong> : bool</p>
<blockquote>
<div><p>If the provided .wav has more than one channel, it will be
converted to mono if <code class="docutils literal"><span class="pre">mono=True</span></code>. (Default value = True)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>audio_data</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of audio samples, normalized to the range [-1., 1.]</p>
</div></blockquote>
<p><strong>fs</strong> : int</p>
<blockquote class="last">
<div><p>Sampling rate of the audio data</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_valued_intervals">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_valued_intervals</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_valued_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Import valued intervals from an annotation file. The file should
consist of three columns: Two consisting of numeric values corresponding to
start and end time of each interval and a third, also of numeric values,
corresponding to the value of each interval. This is primarily useful for
processing events which span a duration and have a numeric value, such as
piano-roll notes which have an onset, offset, and a pitch value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n_events, 2)</p>
<blockquote>
<div><p>Array of event start and end times</p>
</div></blockquote>
<p><strong>values</strong> : np.ndarray, shape=(n_events,)</p>
<blockquote class="last">
<div><p>Array of values</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_key">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_key</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Load key labels from an annotation file. The file should
consist of two string columns: One denoting the key scale degree
(semitone), and the other denoting the mode (major or minor).  The file
should contain only one row.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>key</strong> : str</p>
<blockquote class="last">
<div><p>Key label, in the form <code class="docutils literal"><span class="pre">'(key)</span> <span class="pre">(mode)'</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_tempo">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_tempo</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_tempo" title="Permalink to this definition">¶</a></dt>
<dd><p>Load tempo estimates from an annotation file in MIREX format.
The file should consist of three numeric columns: the first two
correspond to tempo estimates (in beats-per-minute), and the third
denotes the relative confidence of the first value compared to the
second (in the range [0, 1]). The file should contain only one row.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tempi</strong> : np.ndarray, non-negative</p>
<blockquote>
<div><p>The two tempo estimates</p>
</div></blockquote>
<p><strong>weight</strong> : float [0, 1]</p>
<blockquote class="last">
<div><p>The relative importance of <code class="docutils literal"><span class="pre">tempi[0]</span></code> compared to <code class="docutils literal"><span class="pre">tempi[1]</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_ragged_time_series">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_ragged_time_series</code><span class="sig-paren">(</span><em>filename</em>, <em>dtype=&lt;type 'float'&gt;</em>, <em>delimiter='\\s+'</em>, <em>header=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_ragged_time_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function for loading in data from a delimited time series
annotation file with a variable number of columns.
Assumes that column 0 contains time stamps and columns 1 through n contain
values. n may be variable from time stamp to time stamp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>dtype</strong> : function</p>
<blockquote>
<div><p>Data type to apply to values columns.</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
<p><strong>header</strong> : bool</p>
<blockquote>
<div><p>Indicates whether a header row is present or not.
By default, assumes no header is present.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>times</strong> : np.ndarray</p>
<blockquote>
<div><p>array of timestamps (float)</p>
</div></blockquote>
<p><strong>values</strong> : list of np.ndarray</p>
<blockquote class="last">
<div><p>list of arrays of corresponding values</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load a ragged list of tab-delimited multi-f0 midi notes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">load_ragged_time_series</span><span class="p">(</span><span class="s1">&#39;multif0.txt&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
<span class="go">                                          delimiter=&#39;\t&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load a raggled list of space delimited multi-f0 values with a header</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">load_ragged_time_series</span><span class="p">(</span><span class="s1">&#39;labeled_events.csv&#39;</span><span class="p">,</span>
<span class="go">                                          header=True)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-mir_eval.sonify">
<span id="mir-eval-sonify"></span><h3><a class="reference internal" href="#module-mir_eval.sonify" title="mir_eval.sonify"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.sonify</span></code></a><a class="headerlink" href="#module-mir_eval.sonify" title="Permalink to this headline">¶</a></h3>
<p>Methods which sonify annotations for “evaluation by ear”.
All functions return a raw signal at the specified sampling rate.</p>
<dl class="function">
<dt id="mir_eval.sonify.clicks">
<code class="descclassname">mir_eval.sonify.</code><code class="descname">clicks</code><span class="sig-paren">(</span><em>times</em>, <em>fs</em>, <em>click=None</em>, <em>length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.sonify.clicks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the signal ‘click’ placed at each specified time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : np.ndarray</p>
<blockquote>
<div><p>times to place clicks, in seconds</p>
</div></blockquote>
<p><strong>fs</strong> : int</p>
<blockquote>
<div><p>desired sampling rate of the output signal</p>
</div></blockquote>
<p><strong>click</strong> : np.ndarray</p>
<blockquote>
<div><p>click signal, defaults to a 1 kHz blip</p>
</div></blockquote>
<p><strong>length</strong> : int</p>
<blockquote>
<div><p>desired number of samples in the output signal,
defaults to <code class="docutils literal"><span class="pre">times.max()*fs</span> <span class="pre">+</span> <span class="pre">click.shape[0]</span> <span class="pre">+</span> <span class="pre">1</span></code></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>click_signal</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Synthesized click signal</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.sonify.time_frequency">
<code class="descclassname">mir_eval.sonify.</code><code class="descname">time_frequency</code><span class="sig-paren">(</span><em>gram</em>, <em>frequencies</em>, <em>times</em>, <em>fs</em>, <em>function=&lt;ufunc 'sin'&gt;</em>, <em>length=None</em>, <em>n_dec=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.sonify.time_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse synthesis of a time-frequency representation of a signal</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gram</strong> : np.ndarray</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">gram[n,</span> <span class="pre">m]</span></code> is the magnitude of <code class="docutils literal"><span class="pre">frequencies[n]</span></code>
from <code class="docutils literal"><span class="pre">times[m]</span></code> to <code class="docutils literal"><span class="pre">times[m</span> <span class="pre">+</span> <span class="pre">1]</span></code></p>
<p>Non-positive magnitudes are interpreted as silence.</p>
</div></blockquote>
<p><strong>frequencies</strong> : np.ndarray</p>
<blockquote>
<div><p>array of size <code class="docutils literal"><span class="pre">gram.shape[0]</span></code> denoting the frequency of
each row of gram</p>
</div></blockquote>
<p><strong>times</strong> : np.ndarray, shape= <code class="docutils literal"><span class="pre">(gram.shape[1],)</span></code> or <code class="docutils literal"><span class="pre">(gram.shape[1],</span> <span class="pre">2)</span></code></p>
<blockquote>
<div><p>Either the start time of each column in the gram,
or the time interval corresponding to each column.</p>
</div></blockquote>
<p><strong>fs</strong> : int</p>
<blockquote>
<div><p>desired sampling rate of the output signal</p>
</div></blockquote>
<p><strong>function</strong> : function</p>
<blockquote>
<div><p>function to use to synthesize notes, should be <img class="math" src="_images/math/6f064faadf14a1d739a4ca4e1ea4aeeb3a342dfe.png" alt="2\pi"/>-periodic</p>
</div></blockquote>
<p><strong>length</strong> : int</p>
<blockquote>
<div><p>desired number of samples in the output signal,
defaults to <code class="docutils literal"><span class="pre">times[-1]*fs</span></code></p>
</div></blockquote>
<p><strong>n_dec</strong> : int</p>
<blockquote>
<div><p>the number of decimals used to approximate each sonfied frequency.
Defaults to 1 decimal place. Higher precision will be slower.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>synthesized version of the piano roll</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.sonify.pitch_contour">
<code class="descclassname">mir_eval.sonify.</code><code class="descname">pitch_contour</code><span class="sig-paren">(</span><em>times</em>, <em>frequencies</em>, <em>fs</em>, <em>amplitudes=None</em>, <em>function=&lt;ufunc 'sin'&gt;</em>, <em>length=None</em>, <em>kind='linear'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.sonify.pitch_contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Sonify a pitch contour.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : np.ndarray</p>
<blockquote>
<div><p>time indices for each frequency measurement, in seconds</p>
</div></blockquote>
<p><strong>frequencies</strong> : np.ndarray</p>
<blockquote>
<div><p>frequency measurements, in Hz.
Non-positive measurements will be interpreted as un-voiced samples.</p>
</div></blockquote>
<p><strong>fs</strong> : int</p>
<blockquote>
<div><p>desired sampling rate of the output signal</p>
</div></blockquote>
<p><strong>amplitudes</strong> : np.ndarray</p>
<blockquote>
<div><p>amplitude measurments, nonnegative
defaults to <code class="docutils literal"><span class="pre">np.ones((length,))</span></code></p>
</div></blockquote>
<p><strong>function</strong> : function</p>
<blockquote>
<div><p>function to use to synthesize notes, should be <img class="math" src="_images/math/6f064faadf14a1d739a4ca4e1ea4aeeb3a342dfe.png" alt="2\pi"/>-periodic</p>
</div></blockquote>
<p><strong>length</strong> : int</p>
<blockquote>
<div><p>desired number of samples in the output signal,
defaults to <code class="docutils literal"><span class="pre">max(times)*fs</span></code></p>
</div></blockquote>
<p><strong>kind</strong> : str</p>
<blockquote>
<div><p>Interpolation mode for the frequency and amplitude values.
See: <code class="docutils literal"><span class="pre">scipy.interpolate.interp1d</span></code> for valid settings.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>synthesized version of the pitch contour</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.sonify.chroma">
<code class="descclassname">mir_eval.sonify.</code><code class="descname">chroma</code><span class="sig-paren">(</span><em>chromagram</em>, <em>times</em>, <em>fs</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.sonify.chroma" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse synthesis of a chromagram (semitone matrix)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chromagram</strong> : np.ndarray, shape=(12, times.shape[0])</p>
<blockquote>
<div><p>Chromagram matrix, where each row represents a semitone [C-&gt;Bb]
i.e., <code class="docutils literal"><span class="pre">chromagram[3,</span> <span class="pre">j]</span></code> is the magnitude of D# from <code class="docutils literal"><span class="pre">times[j]</span></code> to
<code class="docutils literal"><span class="pre">times[j</span> <span class="pre">+</span> <span class="pre">1]</span></code></p>
</div></blockquote>
<p><strong>times: np.ndarray, shape=(len(chord_labels),) or (len(chord_labels), 2)</strong></p>
<blockquote>
<div><p>Either the start time of each column in the chromagram,
or the time interval corresponding to each column.</p>
</div></blockquote>
<p><strong>fs</strong> : int</p>
<blockquote>
<div><p>Sampling rate to synthesize audio data at</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments to pass to
<a class="reference internal" href="#mir_eval.sonify.time_frequency" title="mir_eval.sonify.time_frequency"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.sonify.time_frequency()</span></code></a></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Synthesized chromagram</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.sonify.chords">
<code class="descclassname">mir_eval.sonify.</code><code class="descname">chords</code><span class="sig-paren">(</span><em>chord_labels</em>, <em>intervals</em>, <em>fs</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.sonify.chords" title="Permalink to this definition">¶</a></dt>
<dd><p>Synthesizes chord labels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chord_labels</strong> : list of str</p>
<blockquote>
<div><p>List of chord label strings.</p>
</div></blockquote>
<p><strong>intervals</strong> : np.ndarray, shape=(len(chord_labels), 2)</p>
<blockquote>
<div><p>Start and end times of each chord label</p>
</div></blockquote>
<p><strong>fs</strong> : int</p>
<blockquote>
<div><p>Sampling rate to synthesize at</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments to pass to
<a class="reference internal" href="#mir_eval.sonify.time_frequency" title="mir_eval.sonify.time_frequency"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.sonify.time_frequency()</span></code></a></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Synthesized chord labels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-mir_eval.display">
<span id="mir-eval-display"></span><h3><a class="reference internal" href="#module-mir_eval.display" title="mir_eval.display"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.display</span></code></a><a class="headerlink" href="#module-mir_eval.display" title="Permalink to this headline">¶</a></h3>
<p>Display functions</p>
<dl class="function">
<dt id="mir_eval.display.segments">
<code class="descclassname">mir_eval.display.</code><code class="descname">segments</code><span class="sig-paren">(</span><em>intervals</em>, <em>labels</em>, <em>base=None</em>, <em>height=None</em>, <em>text=False</em>, <em>text_kw=None</em>, <em>ax=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a segmentation as a set of disjoint rectangles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>base</strong> : number</p>
<blockquote>
<div><p>The vertical position of the base of the rectangles.
By default, this will be the bottom of the plot.</p>
</div></blockquote>
<p><strong>height</strong> : number</p>
<blockquote>
<div><p>The height of the rectangles.
By default, this will be the top of the plot (minus <code class="docutils literal"><span class="pre">base</span></code>).</p>
</div></blockquote>
<p><strong>text</strong> : bool</p>
<blockquote>
<div><p>If true, each segment’s label is displayed in its
upper-left corner</p>
</div></blockquote>
<p><strong>text_kw</strong> : dict</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">text</span> <span class="pre">==</span> <span class="pre">True</span></code>, the properties of the text
object can be specified here.
See <code class="docutils literal"><span class="pre">matplotlib.pyplot.Text</span></code> for valid parameters</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.pyplot.axes</p>
<blockquote>
<div><p>An axis handle on which to draw the segmentation.
If none is provided, a new set of axes is created.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments to pass to
<code class="docutils literal"><span class="pre">matplotlib.patches.Rectangle</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.pyplot.axes._subplots.AxesSubplot</p>
<blockquote class="last">
<div><p>A handle to the (possibly constructed) plot axes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.display.labeled_intervals">
<code class="descclassname">mir_eval.display.</code><code class="descname">labeled_intervals</code><span class="sig-paren">(</span><em>intervals</em>, <em>labels</em>, <em>label_set=None</em>, <em>base=None</em>, <em>height=None</em>, <em>extend_labels=True</em>, <em>ax=None</em>, <em>tick=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.labeled_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot labeled intervals with each label on its own row.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>label_set</strong> : list</p>
<blockquote>
<div><p>An (ordered) list of labels to determine the plotting order.
If not provided, the labels will be inferred from
<code class="docutils literal"><span class="pre">ax.get_yticklabels()</span></code>.
If no <code class="docutils literal"><span class="pre">yticklabels</span></code> exist, then the sorted set of unique values
in <code class="docutils literal"><span class="pre">labels</span></code> is taken as the label set.</p>
</div></blockquote>
<p><strong>base</strong> : np.ndarray, shape=(n,), optional</p>
<blockquote>
<div><p>Vertical positions of each label.
By default, labels are positioned at integers
<code class="docutils literal"><span class="pre">np.arange(len(labels))</span></code>.</p>
</div></blockquote>
<p><strong>height</strong> : scalar or np.ndarray, shape=(n,), optional</p>
<blockquote>
<div><p>Height for each label.
If scalar, the same value is applied to all labels.
By default, each label has <code class="docutils literal"><span class="pre">height=1</span></code>.</p>
</div></blockquote>
<p><strong>extend_labels</strong> : bool</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">False</span></code>, only values of <code class="docutils literal"><span class="pre">labels</span></code> that also exist in
<code class="docutils literal"><span class="pre">label_set</span></code> will be shown.</p>
<p>If <code class="docutils literal"><span class="pre">True</span></code>, all labels are shown, with those in <cite>labels</cite> but
not in <cite>label_set</cite> appended to the top of the plot.
A horizontal line is drawn to indicate the separation between
values in or out of <code class="docutils literal"><span class="pre">label_set</span></code>.</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.pyplot.axes</p>
<blockquote>
<div><p>An axis handle on which to draw the intervals.
If none is provided, a new set of axes is created.</p>
</div></blockquote>
<p><strong>tick</strong> : bool</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, sets tick positions and labels on the y-axis.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments to pass to
<cite>matplotlib.collection.BrokenBarHCollection</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.pyplot.axes._subplots.AxesSubplot</p>
<blockquote class="last">
<div><p>A handle to the (possibly constructed) plot axes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="mir_eval.display.IntervalFormatter">
<em class="property">class </em><code class="descclassname">mir_eval.display.</code><code class="descname">IntervalFormatter</code><span class="sig-paren">(</span><em>base</em>, <em>ticks</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.IntervalFormatter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">matplotlib.ticker.Formatter</span></code></p>
<p>Ticker formatter for labeled interval plots.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>base</strong> : array-like of int</p>
<blockquote>
<div><p>The base positions of each label</p>
</div></blockquote>
<p><strong>ticks</strong> : array-like of string</p>
<blockquote class="last">
<div><p>The labels for the ticks</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>axis</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="function">
<dt id="mir_eval.display.hierarchy">
<code class="descclassname">mir_eval.display.</code><code class="descname">hierarchy</code><span class="sig-paren">(</span><em>intervals_hier</em>, <em>labels_hier</em>, <em>levels=None</em>, <em>ax=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.hierarchy" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a hierarchical segmentation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals_hier</strong> : list of np.ndarray</p>
<blockquote>
<div><p>A list of segmentation intervals.  Each element should be
an n-by-2 array of segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.
Segmentations should be ordered by increasing specificity.</p>
</div></blockquote>
<p><strong>labels_hier</strong> : list of list-like</p>
<blockquote>
<div><p>A list of segmentation labels.  Each element should
be a list of labels for the corresponding element in
<cite>intervals_hier</cite>.</p>
</div></blockquote>
<p><strong>levels</strong> : list of string</p>
<blockquote>
<div><p>Each element <code class="docutils literal"><span class="pre">levels[i]</span></code> is a label for the <code class="docutils literal"><span class="pre">`i</span></code> th segmentation.
This is used in the legend to denote the levels in a segment hierarchy.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments to <cite>labeled_intervals</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.pyplot.axes._subplots.AxesSubplot</p>
<blockquote class="last">
<div><p>A handle to the (possibly constructed) plot axes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.display.events">
<code class="descclassname">mir_eval.display.</code><code class="descname">events</code><span class="sig-paren">(</span><em>times</em>, <em>labels=None</em>, <em>base=None</em>, <em>height=None</em>, <em>ax=None</em>, <em>text_kw=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.events" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot event times as a set of vertical lines</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>event times, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_events" title="mir_eval.io.load_events"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_events()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_events" title="mir_eval.io.load_labeled_events"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_events()</span></code></a>.</p>
</div></blockquote>
<p><strong>labels</strong> : list, shape=(n,), optional</p>
<blockquote>
<div><p>event labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_events" title="mir_eval.io.load_labeled_events"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_events()</span></code></a>.</p>
</div></blockquote>
<p><strong>base</strong> : number</p>
<blockquote>
<div><p>The vertical position of the base of the line.
By default, this will be the bottom of the plot.</p>
</div></blockquote>
<p><strong>height</strong> : number</p>
<blockquote>
<div><p>The height of the lines.
By default, this will be the top of the plot (minus <cite>base</cite>).</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.pyplot.axes</p>
<blockquote>
<div><p>An axis handle on which to draw the segmentation.
If none is provided, a new set of axes is created.</p>
</div></blockquote>
<p><strong>text_kw</strong> : dict</p>
<blockquote>
<div><p>If <cite>labels</cite> is provided, the properties of the text
objects can be specified here.
See <cite>matplotlib.pyplot.Text</cite> for valid parameters</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments to pass to
<cite>matplotlib.pyplot.vlines</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.pyplot.axes._subplots.AxesSubplot</p>
<blockquote class="last">
<div><p>A handle to the (possibly constructed) plot axes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.display.pitch">
<code class="descclassname">mir_eval.display.</code><code class="descname">pitch</code><span class="sig-paren">(</span><em>times</em>, <em>frequencies</em>, <em>midi=False</em>, <em>unvoiced=False</em>, <em>ax=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.pitch" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize pitch contours</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Sample times of frequencies</p>
</div></blockquote>
<p><strong>frequencies</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>frequencies (in Hz) of the pitch contours.
Voicing is indicated by sign (positive for voiced,
non-positive for non-voiced).</p>
</div></blockquote>
<p><strong>midi</strong> : bool</p>
<blockquote>
<div><p>If <cite>True</cite>, plot on a MIDI-numbered vertical axis.
Otherwise, plot on a linear frequency axis.</p>
</div></blockquote>
<p><strong>unvoiced</strong> : bool</p>
<blockquote>
<div><p>If <cite>True</cite>, unvoiced pitch contours are plotted and indicated
by transparency.</p>
<p>Otherwise, unvoiced pitch contours are omitted from the display.</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.pyplot.axes</p>
<blockquote>
<div><p>An axis handle on which to draw the pitch contours.
If none is provided, a new set of axes is created.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments to <cite>matplotlib.pyplot.plot</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.pyplot.axes._subplots.AxesSubplot</p>
<blockquote class="last">
<div><p>A handle to the (possibly constructed) plot axes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.display.multipitch">
<code class="descclassname">mir_eval.display.</code><code class="descname">multipitch</code><span class="sig-paren">(</span><em>times</em>, <em>frequencies</em>, <em>midi=False</em>, <em>unvoiced=False</em>, <em>ax=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.multipitch" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize multiple f0 measurements</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Sample times of frequencies</p>
</div></blockquote>
<p><strong>frequencies</strong> : list of np.ndarray</p>
<blockquote>
<div><p>frequencies (in Hz) of the pitch measurements.
Voicing is indicated by sign (positive for voiced,
non-positive for non-voiced).</p>
<p><cite>times</cite> and <cite>frequencies</cite> should be in the format produced by
<a class="reference internal" href="#mir_eval.io.load_ragged_time_series" title="mir_eval.io.load_ragged_time_series"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_ragged_time_series()</span></code></a></p>
</div></blockquote>
<p><strong>midi</strong> : bool</p>
<blockquote>
<div><p>If <cite>True</cite>, plot on a MIDI-numbered vertical axis.
Otherwise, plot on a linear frequency axis.</p>
</div></blockquote>
<p><strong>unvoiced</strong> : bool</p>
<blockquote>
<div><p>If <cite>True</cite>, unvoiced pitches are plotted and indicated
by transparency.</p>
<p>Otherwise, unvoiced pitches are omitted from the display.</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.pyplot.axes</p>
<blockquote>
<div><p>An axis handle on which to draw the pitch contours.
If none is provided, a new set of axes is created.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments to <cite>plt.scatter</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.pyplot.axes._subplots.AxesSubplot</p>
<blockquote class="last">
<div><p>A handle to the (possibly constructed) plot axes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.display.piano_roll">
<code class="descclassname">mir_eval.display.</code><code class="descname">piano_roll</code><span class="sig-paren">(</span><em>intervals</em>, <em>pitches=None</em>, <em>midi=None</em>, <em>ax=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.piano_roll" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a quantized piano roll as intervals</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>timing intervals for notes</p>
</div></blockquote>
<p><strong>pitches</strong> : np.ndarray, shape=(n,), optional</p>
<blockquote>
<div><p>pitches of notes (in Hz).</p>
</div></blockquote>
<p><strong>midi</strong> : np.ndarray, shape=(n,), optional</p>
<blockquote>
<div><p>pitches of notes (in MIDI numbers).</p>
<p>At least one of <code class="docutils literal"><span class="pre">pitches</span></code> or <code class="docutils literal"><span class="pre">midi</span></code> must be provided.</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.pyplot.axes</p>
<blockquote>
<div><p>An axis handle on which to draw the intervals.
If none is provided, a new set of axes is created.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments to <a class="reference internal" href="#mir_eval.display.labeled_intervals" title="mir_eval.display.labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">labeled_intervals()</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.pyplot.axes._subplots.AxesSubplot</p>
<blockquote class="last">
<div><p>A handle to the (possibly constructed) plot axes</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.display.separation">
<code class="descclassname">mir_eval.display.</code><code class="descname">separation</code><span class="sig-paren">(</span><em>sources</em>, <em>fs=22050</em>, <em>labels=None</em>, <em>alpha=0.75</em>, <em>ax=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.separation" title="Permalink to this definition">¶</a></dt>
<dd><p>Source-separation visualization</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sources</strong> : np.ndarray, shape=(nsrc, nsampl)</p>
<blockquote>
<div><p>A list of waveform buffers corresponding to each source</p>
</div></blockquote>
<p><strong>fs</strong> : number &gt; 0</p>
<blockquote>
<div><p>The sampling rate</p>
</div></blockquote>
<p><strong>labels</strong> : list of strings</p>
<blockquote>
<div><p>An optional list of descriptors corresponding to each source</p>
</div></blockquote>
<p><strong>alpha</strong> : float in [0, 1]</p>
<blockquote>
<div><p>Maximum alpha (opacity) of spectrogram values.</p>
</div></blockquote>
<p><strong>ax</strong> : matplotlib.pyplot.axes</p>
<blockquote>
<div><p>An axis handle on which to draw the spectrograms.
If none is provided, a new set of axes is created.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments to <code class="docutils literal"><span class="pre">scipy.signal.spectrogram</span></code></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">ax</p>
<blockquote class="last">
<div><p>The axis handle for this plot</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.display.ticker_notes">
<code class="descclassname">mir_eval.display.</code><code class="descname">ticker_notes</code><span class="sig-paren">(</span><em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.ticker_notes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the y-axis of the given axes to MIDI notes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.pyplot.axes</p>
<blockquote class="last">
<div><p>The axes handle to apply the ticker.
By default, uses the current axes handle.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.display.ticker_pitch">
<code class="descclassname">mir_eval.display.</code><code class="descname">ticker_pitch</code><span class="sig-paren">(</span><em>ax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.display.ticker_pitch" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the y-axis of the given axes to MIDI frequencies</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.pyplot.axes</p>
<blockquote class="last">
<div><p>The axes handle to apply the ticker.
By default, uses the current axes handle.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="changes">
<h2>Changes<a class="headerlink" href="#changes" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="changes.html">Changes</a></li>
</ul>
</div>
</div>
<div class="section" id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">mir_eval</span></code> Documentation</a><ul>
<li><a class="reference internal" href="#installing-mir-eval">Installing <code class="docutils literal"><span class="pre">mir_eval</span></code></a></li>
<li><a class="reference internal" href="#using-mir-eval">Using <code class="docutils literal"><span class="pre">mir_eval</span></code></a></li>
<li><a class="reference internal" href="#mir-eval"><code class="docutils literal"><span class="pre">mir_eval</span></code></a><ul>
<li><a class="reference internal" href="#module-mir_eval.beat"><code class="docutils literal"><span class="pre">mir_eval.beat</span></code></a><ul>
<li><a class="reference internal" href="#conventions">Conventions</a></li>
<li><a class="reference internal" href="#metrics">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.chord"><code class="docutils literal"><span class="pre">mir_eval.chord</span></code></a><ul>
<li><a class="reference internal" href="#id2">Conventions</a></li>
<li><a class="reference internal" href="#id4">Metrics</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.melody"><code class="docutils literal"><span class="pre">mir_eval.melody</span></code></a><ul>
<li><a class="reference internal" href="#id6">Conventions</a></li>
<li><a class="reference internal" href="#id7">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.multipitch"><code class="docutils literal"><span class="pre">mir_eval.multipitch</span></code></a><ul>
<li><a class="reference internal" href="#id10">Conventions</a></li>
<li><a class="reference internal" href="#id13">Metrics</a></li>
<li><a class="reference internal" href="#id14">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.onset"><code class="docutils literal"><span class="pre">mir_eval.onset</span></code></a><ul>
<li><a class="reference internal" href="#id15">Conventions</a></li>
<li><a class="reference internal" href="#id16">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.pattern"><code class="docutils literal"><span class="pre">mir_eval.pattern</span></code></a><ul>
<li><a class="reference internal" href="#id17">Conventions</a></li>
<li><a class="reference internal" href="#id18">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.segment"><code class="docutils literal"><span class="pre">mir_eval.segment</span></code></a><ul>
<li><a class="reference internal" href="#id19">Conventions</a></li>
<li><a class="reference internal" href="#id20">Metrics</a></li>
<li><a class="reference internal" href="#id26">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.hierarchy"><code class="docutils literal"><span class="pre">mir_eval.hierarchy</span></code></a><ul>
<li><a class="reference internal" href="#id27">Conventions</a></li>
<li><a class="reference internal" href="#id28">Metrics</a></li>
<li><a class="reference internal" href="#id29">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.separation"><code class="docutils literal"><span class="pre">mir_eval.separation</span></code></a><ul>
<li><a class="reference internal" href="#id32">Conventions</a></li>
<li><a class="reference internal" href="#id33">Metrics</a></li>
<li><a class="reference internal" href="#id34">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.tempo"><code class="docutils literal"><span class="pre">mir_eval.tempo</span></code></a><ul>
<li><a class="reference internal" href="#id39">Conventions</a></li>
<li><a class="reference internal" href="#id40">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.transcription"><code class="docutils literal"><span class="pre">mir_eval.transcription</span></code></a><ul>
<li><a class="reference internal" href="#id41">Conventions</a></li>
<li><a class="reference internal" href="#id42">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.transcription_velocity"><code class="docutils literal"><span class="pre">mir_eval.transcription_velocity</span></code></a><ul>
<li><a class="reference internal" href="#id44">Conventions</a></li>
<li><a class="reference internal" href="#id45">Metrics</a></li>
<li><a class="reference internal" href="#id46">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.key"><code class="docutils literal"><span class="pre">mir_eval.key</span></code></a><ul>
<li><a class="reference internal" href="#id47">Conventions</a></li>
<li><a class="reference internal" href="#id48">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.util"><code class="docutils literal"><span class="pre">mir_eval.util</span></code></a></li>
<li><a class="reference internal" href="#module-mir_eval.io"><code class="docutils literal"><span class="pre">mir_eval.io</span></code></a></li>
<li><a class="reference internal" href="#module-mir_eval.sonify"><code class="docutils literal"><span class="pre">mir_eval.sonify</span></code></a></li>
<li><a class="reference internal" href="#module-mir_eval.display"><code class="docutils literal"><span class="pre">mir_eval.display</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#changes">Changes</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
</ul>

  <h4>Next topic</h4>
  <p class="topless"><a href="changes.html"
                        title="next chapter">Changes</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="changes.html" title="Changes"
             >next</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">mir_eval 0.5 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014, Colin Raffel et al..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>